category,name,formula_latex,formula_ascii,description,parameters,parameter_values,complexity_time,complexity_space,pipeline_stages,is_lossless,prerequisites
ENTROPY_MEASURE,Shannon Entropy,H(X) = -\sum_{i=1}^{n} p(x_i) \log_2 p(x_i),H(X) = -SUM(p(x_i) * log2(p(x_i))) for i=1 to n,Fundamental measure of information content; theoretical minimum bits per symbol,"{""n"": ""alphabet size"", ""p(x_i)"": ""probability of symbol i""}","{""base"": 2}",O(n),O(n),[0],True,[]
ENTROPY_MEASURE,Shannon Entropy,H(X) = -\sum_{i=1}^{n} p(x_i) \log_2 p(x_i),H(X) = -SUM(p(x_i) * log2(p(x_i))) for i=1 to n,Fundamental measure of information content; theoretical minimum bits per symbol,"{""n"": ""alphabet size"", ""p(x_i)"": ""probability of symbol i""}","{""base"": ""e""}",O(n),O(n),[0],True,[]
ENTROPY_MEASURE,Shannon Entropy,H(X) = -\sum_{i=1}^{n} p(x_i) \log_2 p(x_i),H(X) = -SUM(p(x_i) * log2(p(x_i))) for i=1 to n,Fundamental measure of information content; theoretical minimum bits per symbol,"{""n"": ""alphabet size"", ""p(x_i)"": ""probability of symbol i""}","{""base"": 10}",O(n),O(n),[0],True,[]
ENTROPY_MEASURE,Conditional Entropy,H(X|Y) = -\sum_{y} p(y) \sum_{x} p(x|y) \log_2 p(x|y),H(X|Y) = -SUM_y(p(y) * SUM_x(p(x|y) * log2(p(x|y)))),Expected entropy of X given knowledge of Y; basis for context modeling,"{""X"": ""target variable"", ""Y"": ""conditioning variable""}",{},O(|X| * |Y|),O(|X| * |Y|),[0],True,[]
ENTROPY_MEASURE,Mutual Information,"I(X;Y) = H(X) - H(X|Y) = \sum_{x,y} p(x,y) \log_2 \frac{p(x,y)}{p(x)p(y)}","I(X;Y) = H(X) - H(X|Y) = SUM(p(x,y) * log2(p(x,y) / (p(x)*p(y))))",Information shared between two variables; guides context selection,"{""X"": ""first variable"", ""Y"": ""second variable""}",{},O(|X| * |Y|),O(|X| * |Y|),[0],True,[]
ENTROPY_MEASURE,Kolmogorov Complexity,K(x) = \min\{|p| : U(p) = x\},K(x) = min{|p| : U(p) = x} (length of shortest program),Theoretical minimum description length; incomputable but guides algorithm design,"{""U"": ""universal Turing machine"", ""p"": ""program""}",{},Incomputable,Incomputable,[0],True,[]
ENTROPY_MEASURE,Rényi Entropy,H_\alpha(X) = \frac{1}{1-\alpha} \log_2 \sum_{i=1}^{n} p_i^\alpha,H_alpha(X) = (1/(1-alpha)) * log2(SUM(p_i^alpha)),"Generalized entropy; alpha=1 gives Shannon entropy, alpha=0 gives Hartley entropy","{""alpha"": ""order parameter (\u03b1 \u2265 0, \u03b1 \u2260 1)""}","{""alpha"": 0}",O(n),O(n),[0],True,[]
ENTROPY_MEASURE,Rényi Entropy,H_\alpha(X) = \frac{1}{1-\alpha} \log_2 \sum_{i=1}^{n} p_i^\alpha,H_alpha(X) = (1/(1-alpha)) * log2(SUM(p_i^alpha)),"Generalized entropy; alpha=1 gives Shannon entropy, alpha=0 gives Hartley entropy","{""alpha"": ""order parameter (\u03b1 \u2265 0, \u03b1 \u2260 1)""}","{""alpha"": 0.5}",O(n),O(n),[0],True,[]
ENTROPY_MEASURE,Rényi Entropy,H_\alpha(X) = \frac{1}{1-\alpha} \log_2 \sum_{i=1}^{n} p_i^\alpha,H_alpha(X) = (1/(1-alpha)) * log2(SUM(p_i^alpha)),"Generalized entropy; alpha=1 gives Shannon entropy, alpha=0 gives Hartley entropy","{""alpha"": ""order parameter (\u03b1 \u2265 0, \u03b1 \u2260 1)""}","{""alpha"": 2}",O(n),O(n),[0],True,[]
ENTROPY_MEASURE,Rényi Entropy,H_\alpha(X) = \frac{1}{1-\alpha} \log_2 \sum_{i=1}^{n} p_i^\alpha,H_alpha(X) = (1/(1-alpha)) * log2(SUM(p_i^alpha)),"Generalized entropy; alpha=1 gives Shannon entropy, alpha=0 gives Hartley entropy","{""alpha"": ""order parameter (\u03b1 \u2265 0, \u03b1 \u2260 1)""}","{""alpha"": Infinity}",O(n),O(n),[0],True,[]
TRANSFORM,Burrows-Wheeler Transform,"BWT(s) = L \text{ where } M = \text{sort}(\text{rotations}(s)), L = \text{last\_column}(M)",BWT(s) = last_column(sort(all_rotations(s))),Reversible transform that groups similar contexts together; basis for bzip2,"{""s"": ""input string""}",{},O(n log n),O(n),[1],True,[]
TRANSFORM,Move-to-Front Transform,MTF(s_i) = \text{position of } s_i \text{ in list } L; \text{ move } s_i \text{ to front},"MTF(s_i) = index_of(s_i, L); then move s_i to L[0]",Exploits locality by outputting small numbers for recently-seen symbols,"{""alphabet_size"": ""size of symbol alphabet""}","{""alphabet_size"": 256}",O(n * |Σ|),O(|Σ|),[2],True,"[""Burrows-Wheeler Transform""]"
TRANSFORM,Move-to-Front Transform,MTF(s_i) = \text{position of } s_i \text{ in list } L; \text{ move } s_i \text{ to front},"MTF(s_i) = index_of(s_i, L); then move s_i to L[0]",Exploits locality by outputting small numbers for recently-seen symbols,"{""alphabet_size"": ""size of symbol alphabet""}","{""alphabet_size"": 65536}",O(n * |Σ|),O(|Σ|),[2],True,"[""Burrows-Wheeler Transform""]"
TRANSFORM,Discrete Cosine Transform,X_k = \sum_{n=0}^{N-1} x_n \cos\left[\frac{\pi}{N}\left(n+\frac{1}{2}\right)k\right],X_k = SUM(x_n * cos(pi/N * (n + 0.5) * k)) for n=0 to N-1,Frequency-domain transform; used in JPEG (lossy variant exists),"{""N"": ""block size""}","{""N"": 8}",O(n log n),O(n),[1],True,[]
TRANSFORM,Discrete Cosine Transform,X_k = \sum_{n=0}^{N-1} x_n \cos\left[\frac{\pi}{N}\left(n+\frac{1}{2}\right)k\right],X_k = SUM(x_n * cos(pi/N * (n + 0.5) * k)) for n=0 to N-1,Frequency-domain transform; used in JPEG (lossy variant exists),"{""N"": ""block size""}","{""N"": 16}",O(n log n),O(n),[1],True,[]
TRANSFORM,Discrete Cosine Transform,X_k = \sum_{n=0}^{N-1} x_n \cos\left[\frac{\pi}{N}\left(n+\frac{1}{2}\right)k\right],X_k = SUM(x_n * cos(pi/N * (n + 0.5) * k)) for n=0 to N-1,Frequency-domain transform; used in JPEG (lossy variant exists),"{""N"": ""block size""}","{""N"": 32}",O(n log n),O(n),[1],True,[]
TRANSFORM,Delta Encoding,"\Delta_i = x_i - x_{i-1}, \quad x_0' = x_0",delta_i = x_i - x_{i-1}; x_0' = x_0,Stores differences between consecutive values; effective for sorted/smooth data,"{""order"": ""delta order (1=first difference, 2=second difference)""}","{""order"": 1}",O(n),O(1),[1],True,[]
TRANSFORM,Delta Encoding,"\Delta_i = x_i - x_{i-1}, \quad x_0' = x_0",delta_i = x_i - x_{i-1}; x_0' = x_0,Stores differences between consecutive values; effective for sorted/smooth data,"{""order"": ""delta order (1=first difference, 2=second difference)""}","{""order"": 2}",O(n),O(1),[1],True,[]
TRANSFORM,Delta Encoding,"\Delta_i = x_i - x_{i-1}, \quad x_0' = x_0",delta_i = x_i - x_{i-1}; x_0' = x_0,Stores differences between consecutive values; effective for sorted/smooth data,"{""order"": ""delta order (1=first difference, 2=second difference)""}","{""order"": 3}",O(n),O(1),[1],True,[]
TRANSFORM,XOR Delta,d_i = x_i \oplus x_{i-1},d_i = x_i XOR x_{i-1},Bitwise delta; preserves structure in binary data with similar consecutive values,{},{},O(n),O(1),[1],True,[]
TRANSFORM,Integer Wavelet Transform (Lifting),d_j[n] = x[2n+1] - \lfloor(x[2n] + x[2n+2])/2\rfloor; \quad s_j[n] = x[2n] + \lfloor d_j[n]/4 \rfloor,d_j[n] = x[2n+1] - floor((x[2n] + x[2n+2])/2); s_j[n] = x[2n] + floor(d_j[n]/4),Lossless wavelet via integer lifting scheme; used in JPEG 2000 lossless mode,"{""levels"": ""decomposition levels""}","{""levels"": 1}",O(n),O(n),[1],True,[]
TRANSFORM,Integer Wavelet Transform (Lifting),d_j[n] = x[2n+1] - \lfloor(x[2n] + x[2n+2])/2\rfloor; \quad s_j[n] = x[2n] + \lfloor d_j[n]/4 \rfloor,d_j[n] = x[2n+1] - floor((x[2n] + x[2n+2])/2); s_j[n] = x[2n] + floor(d_j[n]/4),Lossless wavelet via integer lifting scheme; used in JPEG 2000 lossless mode,"{""levels"": ""decomposition levels""}","{""levels"": 2}",O(n),O(n),[1],True,[]
TRANSFORM,Integer Wavelet Transform (Lifting),d_j[n] = x[2n+1] - \lfloor(x[2n] + x[2n+2])/2\rfloor; \quad s_j[n] = x[2n] + \lfloor d_j[n]/4 \rfloor,d_j[n] = x[2n+1] - floor((x[2n] + x[2n+2])/2); s_j[n] = x[2n] + floor(d_j[n]/4),Lossless wavelet via integer lifting scheme; used in JPEG 2000 lossless mode,"{""levels"": ""decomposition levels""}","{""levels"": 3}",O(n),O(n),[1],True,[]
TRANSFORM,Integer Wavelet Transform (Lifting),d_j[n] = x[2n+1] - \lfloor(x[2n] + x[2n+2])/2\rfloor; \quad s_j[n] = x[2n] + \lfloor d_j[n]/4 \rfloor,d_j[n] = x[2n+1] - floor((x[2n] + x[2n+2])/2); s_j[n] = x[2n] + floor(d_j[n]/4),Lossless wavelet via integer lifting scheme; used in JPEG 2000 lossless mode,"{""levels"": ""decomposition levels""}","{""levels"": 4}",O(n),O(n),[1],True,[]
TRANSFORM,Byte Pair Encoding (Transform),"BPE(s) = \text{replace most frequent pair } (a,b) \text{ with new symbol } c","BPE(s) = iteratively_replace(most_frequent_pair, new_symbol)",Iteratively replaces frequent byte pairs; creates implicit dictionary,"{""max_iterations"": ""maximum replacement iterations""}","{""max_iterations"": 100}",O(n * iterations),O(|vocab|),[1],True,[]
TRANSFORM,Byte Pair Encoding (Transform),"BPE(s) = \text{replace most frequent pair } (a,b) \text{ with new symbol } c","BPE(s) = iteratively_replace(most_frequent_pair, new_symbol)",Iteratively replaces frequent byte pairs; creates implicit dictionary,"{""max_iterations"": ""maximum replacement iterations""}","{""max_iterations"": 1000}",O(n * iterations),O(|vocab|),[1],True,[]
TRANSFORM,Byte Pair Encoding (Transform),"BPE(s) = \text{replace most frequent pair } (a,b) \text{ with new symbol } c","BPE(s) = iteratively_replace(most_frequent_pair, new_symbol)",Iteratively replaces frequent byte pairs; creates implicit dictionary,"{""max_iterations"": ""maximum replacement iterations""}","{""max_iterations"": 10000}",O(n * iterations),O(|vocab|),[1],True,[]
PREDICTOR,Order-N Markov Predictor,"P(x_i | x_{i-1}, ..., x_{i-n}) = \frac{C(x_{i-n}...x_i)}{C(x_{i-n}...x_{i-1})}",P(x_i | context) = count(context + x_i) / count(context),Predicts next symbol based on preceding n symbols; basis for PPM,"{""order"": ""context length n""}","{""order"": 0}",O(n),O(|Σ|^order),[2],True,[]
PREDICTOR,Order-N Markov Predictor,"P(x_i | x_{i-1}, ..., x_{i-n}) = \frac{C(x_{i-n}...x_i)}{C(x_{i-n}...x_{i-1})}",P(x_i | context) = count(context + x_i) / count(context),Predicts next symbol based on preceding n symbols; basis for PPM,"{""order"": ""context length n""}","{""order"": 1}",O(n),O(|Σ|^order),[2],True,[]
PREDICTOR,Order-N Markov Predictor,"P(x_i | x_{i-1}, ..., x_{i-n}) = \frac{C(x_{i-n}...x_i)}{C(x_{i-n}...x_{i-1})}",P(x_i | context) = count(context + x_i) / count(context),Predicts next symbol based on preceding n symbols; basis for PPM,"{""order"": ""context length n""}","{""order"": 2}",O(n),O(|Σ|^order),[2],True,[]
PREDICTOR,Order-N Markov Predictor,"P(x_i | x_{i-1}, ..., x_{i-n}) = \frac{C(x_{i-n}...x_i)}{C(x_{i-n}...x_{i-1})}",P(x_i | context) = count(context + x_i) / count(context),Predicts next symbol based on preceding n symbols; basis for PPM,"{""order"": ""context length n""}","{""order"": 3}",O(n),O(|Σ|^order),[2],True,[]
PREDICTOR,Order-N Markov Predictor,"P(x_i | x_{i-1}, ..., x_{i-n}) = \frac{C(x_{i-n}...x_i)}{C(x_{i-n}...x_{i-1})}",P(x_i | context) = count(context + x_i) / count(context),Predicts next symbol based on preceding n symbols; basis for PPM,"{""order"": ""context length n""}","{""order"": 4}",O(n),O(|Σ|^order),[2],True,[]
PREDICTOR,Order-N Markov Predictor,"P(x_i | x_{i-1}, ..., x_{i-n}) = \frac{C(x_{i-n}...x_i)}{C(x_{i-n}...x_{i-1})}",P(x_i | context) = count(context + x_i) / count(context),Predicts next symbol based on preceding n symbols; basis for PPM,"{""order"": ""context length n""}","{""order"": 5}",O(n),O(|Σ|^order),[2],True,[]
PREDICTOR,Order-N Markov Predictor,"P(x_i | x_{i-1}, ..., x_{i-n}) = \frac{C(x_{i-n}...x_i)}{C(x_{i-n}...x_{i-1})}",P(x_i | context) = count(context + x_i) / count(context),Predicts next symbol based on preceding n symbols; basis for PPM,"{""order"": ""context length n""}","{""order"": 6}",O(n),O(|Σ|^order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 4, ""escape"": ""PPMA""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 4, ""escape"": ""PPMB""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 4, ""escape"": ""PPMC""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 4, ""escape"": ""PPMD""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 4, ""escape"": ""PPMD+""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 5, ""escape"": ""PPMA""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 5, ""escape"": ""PPMB""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 5, ""escape"": ""PPMC""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 5, ""escape"": ""PPMD""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 5, ""escape"": ""PPMD+""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 6, ""escape"": ""PPMA""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 6, ""escape"": ""PPMB""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 6, ""escape"": ""PPMC""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 6, ""escape"": ""PPMD""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 6, ""escape"": ""PPMD+""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 8, ""escape"": ""PPMA""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 8, ""escape"": ""PPMB""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 8, ""escape"": ""PPMC""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 8, ""escape"": ""PPMD""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Prediction by Partial Matching (PPM),P(x) = \lambda_n P_n(x) + (1-\lambda_n)[\lambda_{n-1} P_{n-1}(x) + ...],"P(x) = weighted_blend(P_order_n(x), P_order_n-1(x), ..., P_order_0(x))",Blends predictions from multiple context orders with escape mechanism,"{""max_order"": ""maximum context order"", ""escape"": ""escape method""}","{""max_order"": 8, ""escape"": ""PPMD+""}",O(n * max_order),O(|Σ|^max_order),[2],True,[]
PREDICTOR,Dynamic Markov Compression (DMC),"P(b|state) = \frac{count(state, b) + 1}{count(state) + 2}; \text{ clone states adaptively}","P(bit|state) = (count(state,bit) + 1) / (count(state) + 2); clone when threshold exceeded",Bit-level Markov model that dynamically clones states,"{""threshold"": ""cloning threshold""}","{""threshold"": 2}",O(n),O(states),[2],True,[]
PREDICTOR,Dynamic Markov Compression (DMC),"P(b|state) = \frac{count(state, b) + 1}{count(state) + 2}; \text{ clone states adaptively}","P(bit|state) = (count(state,bit) + 1) / (count(state) + 2); clone when threshold exceeded",Bit-level Markov model that dynamically clones states,"{""threshold"": ""cloning threshold""}","{""threshold"": 4}",O(n),O(states),[2],True,[]
PREDICTOR,Dynamic Markov Compression (DMC),"P(b|state) = \frac{count(state, b) + 1}{count(state) + 2}; \text{ clone states adaptively}","P(bit|state) = (count(state,bit) + 1) / (count(state) + 2); clone when threshold exceeded",Bit-level Markov model that dynamically clones states,"{""threshold"": ""cloning threshold""}","{""threshold"": 8}",O(n),O(states),[2],True,[]
PREDICTOR,Dynamic Markov Compression (DMC),"P(b|state) = \frac{count(state, b) + 1}{count(state) + 2}; \text{ clone states adaptively}","P(bit|state) = (count(state,bit) + 1) / (count(state) + 2); clone when threshold exceeded",Bit-level Markov model that dynamically clones states,"{""threshold"": ""cloning threshold""}","{""threshold"": 16}",O(n),O(states),[2],True,[]
PREDICTOR,Linear Predictor,\hat{x}_i = \sum_{j=1}^{p} a_j x_{i-j},x_hat_i = SUM(a_j * x_{i-j}) for j=1 to p,"Linear combination of previous samples; used in FLAC, PNG","{""order"": ""predictor order p"", ""coefficients"": ""predictor coefficients""}","{""order"": 1}",O(n * p),O(p),"[1, 2]",True,[]
PREDICTOR,Linear Predictor,\hat{x}_i = \sum_{j=1}^{p} a_j x_{i-j},x_hat_i = SUM(a_j * x_{i-j}) for j=1 to p,"Linear combination of previous samples; used in FLAC, PNG","{""order"": ""predictor order p"", ""coefficients"": ""predictor coefficients""}","{""order"": 2}",O(n * p),O(p),"[1, 2]",True,[]
PREDICTOR,Linear Predictor,\hat{x}_i = \sum_{j=1}^{p} a_j x_{i-j},x_hat_i = SUM(a_j * x_{i-j}) for j=1 to p,"Linear combination of previous samples; used in FLAC, PNG","{""order"": ""predictor order p"", ""coefficients"": ""predictor coefficients""}","{""order"": 3}",O(n * p),O(p),"[1, 2]",True,[]
PREDICTOR,Linear Predictor,\hat{x}_i = \sum_{j=1}^{p} a_j x_{i-j},x_hat_i = SUM(a_j * x_{i-j}) for j=1 to p,"Linear combination of previous samples; used in FLAC, PNG","{""order"": ""predictor order p"", ""coefficients"": ""predictor coefficients""}","{""order"": 4}",O(n * p),O(p),"[1, 2]",True,[]
PREDICTOR,PNG Predictors (Paeth),"Paeth(a,b,c) = \text{argmin}_{x \in \{a,b,c\}} |x - (a+b-c)|","Paeth(left, above, upper_left) = closest_to(left + above - upper_left)",2D predictor selecting from left/above/diagonal based on gradient,{},{},O(1) per pixel,O(width),[1],True,[]
PREDICTOR,Context Tree Weighting (CTW),P_s = \frac{1}{2}P_e(s) + \frac{1}{2}P_{s0}P_{s1},P_s = 0.5 * P_estimated(s) + 0.5 * P_child0 * P_child1,Bayesian mixture over all context tree depths; theoretically optimal,"{""max_depth"": ""maximum tree depth""}","{""max_depth"": 8}",O(n * depth),O(2^depth),[2],True,[]
PREDICTOR,Context Tree Weighting (CTW),P_s = \frac{1}{2}P_e(s) + \frac{1}{2}P_{s0}P_{s1},P_s = 0.5 * P_estimated(s) + 0.5 * P_child0 * P_child1,Bayesian mixture over all context tree depths; theoretically optimal,"{""max_depth"": ""maximum tree depth""}","{""max_depth"": 16}",O(n * depth),O(2^depth),[2],True,[]
PREDICTOR,Context Tree Weighting (CTW),P_s = \frac{1}{2}P_e(s) + \frac{1}{2}P_{s0}P_{s1},P_s = 0.5 * P_estimated(s) + 0.5 * P_child0 * P_child1,Bayesian mixture over all context tree depths; theoretically optimal,"{""max_depth"": ""maximum tree depth""}","{""max_depth"": 24}",O(n * depth),O(2^depth),[2],True,[]
PREDICTOR,Context Tree Weighting (CTW),P_s = \frac{1}{2}P_e(s) + \frac{1}{2}P_{s0}P_{s1},P_s = 0.5 * P_estimated(s) + 0.5 * P_child0 * P_child1,Bayesian mixture over all context tree depths; theoretically optimal,"{""max_depth"": ""maximum tree depth""}","{""max_depth"": 32}",O(n * depth),O(2^depth),[2],True,[]
PREDICTOR,Context Tree Weighting (CTW),P_s = \frac{1}{2}P_e(s) + \frac{1}{2}P_{s0}P_{s1},P_s = 0.5 * P_estimated(s) + 0.5 * P_child0 * P_child1,Bayesian mixture over all context tree depths; theoretically optimal,"{""max_depth"": ""maximum tree depth""}","{""max_depth"": 48}",O(n * depth),O(2^depth),[2],True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 4096, ""lookahead_size"": 16}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 4096, ""lookahead_size"": 32}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 4096, ""lookahead_size"": 64}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 4096, ""lookahead_size"": 256}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 8192, ""lookahead_size"": 16}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 8192, ""lookahead_size"": 32}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 8192, ""lookahead_size"": 64}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 8192, ""lookahead_size"": 256}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 32768, ""lookahead_size"": 16}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 32768, ""lookahead_size"": 32}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 32768, ""lookahead_size"": 64}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 32768, ""lookahead_size"": 256}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 65536, ""lookahead_size"": 16}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 65536, ""lookahead_size"": 32}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 65536, ""lookahead_size"": 64}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ77 (Sliding Window),"(d, l, c) \text{ where } d = \text{distance}, l = \text{length}, c = \text{next char}","encode(match) = (distance_back, match_length, next_char)",Replace repeated sequences with back-references; basis for DEFLATE,"{""window_size"": ""sliding window size"", ""lookahead_size"": ""lookahead buffer size""}","{""window_size"": 65536, ""lookahead_size"": 256}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZ78 (Explicit Dictionary),"(i, c) \text{ where } i = \text{dict index}, c = \text{extending char}","encode(phrase) = (dictionary_index, extending_character)",Builds explicit dictionary of phrases; basis for LZW,"{""max_dict_size"": ""maximum dictionary entries""}","{""max_dict_size"": 4096}",O(n),O(dict_size),"[1, 2]",True,[]
DICTIONARY,LZ78 (Explicit Dictionary),"(i, c) \text{ where } i = \text{dict index}, c = \text{extending char}","encode(phrase) = (dictionary_index, extending_character)",Builds explicit dictionary of phrases; basis for LZW,"{""max_dict_size"": ""maximum dictionary entries""}","{""max_dict_size"": 16384}",O(n),O(dict_size),"[1, 2]",True,[]
DICTIONARY,LZ78 (Explicit Dictionary),"(i, c) \text{ where } i = \text{dict index}, c = \text{extending char}","encode(phrase) = (dictionary_index, extending_character)",Builds explicit dictionary of phrases; basis for LZW,"{""max_dict_size"": ""maximum dictionary entries""}","{""max_dict_size"": 65536}",O(n),O(dict_size),"[1, 2]",True,[]
DICTIONARY,LZW (Lempel-Ziv-Welch),\text{output } dict[w]; \text{ add } w+c \text{ to dict}; w = c,output(dict[w]); dict[next_index] = w + c; w = c,"Outputs only dictionary indices; used in GIF, early Unix compress","{""max_bits"": ""maximum code bits""}","{""max_bits"": 12}",O(n),O(2^max_bits),"[1, 2]",True,[]
DICTIONARY,LZW (Lempel-Ziv-Welch),\text{output } dict[w]; \text{ add } w+c \text{ to dict}; w = c,output(dict[w]); dict[next_index] = w + c; w = c,"Outputs only dictionary indices; used in GIF, early Unix compress","{""max_bits"": ""maximum code bits""}","{""max_bits"": 14}",O(n),O(2^max_bits),"[1, 2]",True,[]
DICTIONARY,LZW (Lempel-Ziv-Welch),\text{output } dict[w]; \text{ add } w+c \text{ to dict}; w = c,output(dict[w]); dict[next_index] = w + c; w = c,"Outputs only dictionary indices; used in GIF, early Unix compress","{""max_bits"": ""maximum code bits""}","{""max_bits"": 16}",O(n),O(2^max_bits),"[1, 2]",True,[]
DICTIONARY,LZSS (LZ77 + flags),"\text{flag bit } + \begin{cases} \text{literal byte} & \text{if flag}=0 \\ (d, l) & \text{if flag}=1 \end{cases}","flag_bit + (literal OR (distance, length))",LZ77 variant with flag bits; more efficient for short matches,"{""min_match"": ""minimum match length""}","{""min_match"": 2}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZSS (LZ77 + flags),"\text{flag bit } + \begin{cases} \text{literal byte} & \text{if flag}=0 \\ (d, l) & \text{if flag}=1 \end{cases}","flag_bit + (literal OR (distance, length))",LZ77 variant with flag bits; more efficient for short matches,"{""min_match"": ""minimum match length""}","{""min_match"": 3}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZSS (LZ77 + flags),"\text{flag bit } + \begin{cases} \text{literal byte} & \text{if flag}=0 \\ (d, l) & \text{if flag}=1 \end{cases}","flag_bit + (literal OR (distance, length))",LZ77 variant with flag bits; more efficient for short matches,"{""min_match"": ""minimum match length""}","{""min_match"": 4}",O(n * window),O(window),"[1, 2]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 3, ""lp"": 0, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 3, ""lp"": 0, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 3, ""lp"": 0, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 3, ""lp"": 1, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 3, ""lp"": 1, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 3, ""lp"": 1, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 3, ""lp"": 2, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 3, ""lp"": 2, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 3, ""lp"": 2, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 4, ""lp"": 0, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 4, ""lp"": 0, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 4, ""lp"": 0, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 4, ""lp"": 1, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 4, ""lp"": 1, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 4, ""lp"": 1, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 4, ""lp"": 2, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 4, ""lp"": 2, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 65536, ""lc"": 4, ""lp"": 2, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 3, ""lp"": 0, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 3, ""lp"": 0, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 3, ""lp"": 0, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 3, ""lp"": 1, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 3, ""lp"": 1, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 3, ""lp"": 1, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 3, ""lp"": 2, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 3, ""lp"": 2, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 3, ""lp"": 2, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 4, ""lp"": 0, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 4, ""lp"": 0, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 4, ""lp"": 0, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 4, ""lp"": 1, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 4, ""lp"": 1, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 4, ""lp"": 1, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 4, ""lp"": 2, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 4, ""lp"": 2, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 1048576, ""lc"": 4, ""lp"": 2, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 3, ""lp"": 0, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 3, ""lp"": 0, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 3, ""lp"": 0, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 3, ""lp"": 1, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 3, ""lp"": 1, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 3, ""lp"": 1, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 3, ""lp"": 2, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 3, ""lp"": 2, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 3, ""lp"": 2, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 4, ""lp"": 0, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 4, ""lp"": 0, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 4, ""lp"": 0, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 4, ""lp"": 1, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 4, ""lp"": 1, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 4, ""lp"": 1, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 4, ""lp"": 2, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 4, ""lp"": 2, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 16777216, ""lc"": 4, ""lp"": 2, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 3, ""lp"": 0, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 3, ""lp"": 0, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 3, ""lp"": 0, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 3, ""lp"": 1, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 3, ""lp"": 1, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 3, ""lp"": 1, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 3, ""lp"": 2, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 3, ""lp"": 2, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 3, ""lp"": 2, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 4, ""lp"": 0, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 4, ""lp"": 0, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 4, ""lp"": 0, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 4, ""lp"": 1, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 4, ""lp"": 1, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 4, ""lp"": 1, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 4, ""lp"": 2, ""pb"": 0}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 4, ""lp"": 2, ""pb"": 1}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZMA (Lempel-Ziv-Markov chain),LZ77 + \text{range coder} + \text{context-dependent bit models},LZMA = LZ77_matches + range_coder(context_modeled_bits),"LZ77 with range coding and sophisticated context modeling; used in 7z, xz","{""dict_size"": ""dictionary size"", ""lc"": ""literal context bits"", ""lp"": ""literal position bits"", ""pb"": ""position bits""}","{""dict_size"": 67108864, ""lc"": 4, ""lp"": 2, ""pb"": 2}",O(n),O(dict_size),"[1, 2, 3]",True,[]
DICTIONARY,LZ4 (Fast LZ),"\text{token} = (lit\_len : 4, match\_len : 4) + \text{literals} + \text{offset}","token = (literal_length:4bits, match_length:4bits) + literals + offset16",Extremely fast LZ77 variant optimized for decompression speed,"{""acceleration"": ""compression level""}","{""acceleration"": 1}",O(n),O(64KB),"[1, 2]",True,[]
DICTIONARY,LZ4 (Fast LZ),"\text{token} = (lit\_len : 4, match\_len : 4) + \text{literals} + \text{offset}","token = (literal_length:4bits, match_length:4bits) + literals + offset16",Extremely fast LZ77 variant optimized for decompression speed,"{""acceleration"": ""compression level""}","{""acceleration"": 2}",O(n),O(64KB),"[1, 2]",True,[]
DICTIONARY,LZ4 (Fast LZ),"\text{token} = (lit\_len : 4, match\_len : 4) + \text{literals} + \text{offset}","token = (literal_length:4bits, match_length:4bits) + literals + offset16",Extremely fast LZ77 variant optimized for decompression speed,"{""acceleration"": ""compression level""}","{""acceleration"": 4}",O(n),O(64KB),"[1, 2]",True,[]
DICTIONARY,LZ4 (Fast LZ),"\text{token} = (lit\_len : 4, match\_len : 4) + \text{literals} + \text{offset}","token = (literal_length:4bits, match_length:4bits) + literals + offset16",Extremely fast LZ77 variant optimized for decompression speed,"{""acceleration"": ""compression level""}","{""acceleration"": 8}",O(n),O(64KB),"[1, 2]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 1}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 2}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 3}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 4}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 5}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 6}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 7}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 8}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 9}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 10}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 11}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 12}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 13}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 14}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 15}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 16}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 17}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 18}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 19}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 20}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 21}",O(n),O(window_size),"[1, 2, 3]",True,[]
DICTIONARY,Zstandard (ZSTD),FSE(\text{literals}) + FSE(\text{sequences}) + \text{match copying},ZSTD = FSE_entropy(literals) + FSE_entropy(sequences) + matches,Modern LZ77 + ANS entropy coding; excellent ratio/speed tradeoff,"{""level"": ""compression level""}","{""level"": 22}",O(n),O(window_size),"[1, 2, 3]",True,[]
ENTROPY_CODER,Huffman Coding,L(x) = \lceil -\log_2 p(x) \rceil \text{ (optimal prefix code)},code_length(x) = ceil(-log2(p(x))),Optimal prefix-free code for known distributions; used in DEFLATE,"{""adaptive"": ""whether to adapt code dynamically""}","{""adaptive"": false}",O(n + |Σ| log |Σ|),O(|Σ|),[3],True,[]
ENTROPY_CODER,Huffman Coding,L(x) = \lceil -\log_2 p(x) \rceil \text{ (optimal prefix code)},code_length(x) = ceil(-log2(p(x))),Optimal prefix-free code for known distributions; used in DEFLATE,"{""adaptive"": ""whether to adapt code dynamically""}","{""adaptive"": true}",O(n + |Σ| log |Σ|),O(|Σ|),[3],True,[]
ENTROPY_CODER,Canonical Huffman,\text{code}(s) = \text{base}[len(s)] + \text{rank within length},code(s) = base[length(s)] + rank_within_same_length,Huffman variant requiring only code lengths to reconstruct; used in DEFLATE,{},{},O(n + |Σ| log |Σ|),O(|Σ|),[3],True,[]
ENTROPY_CODER,Arithmetic Coding,"[low, high) \leftarrow [low + range \cdot CDF(x-1), low + range \cdot CDF(x))","[low, high) = [low + range*CDF(x-1), low + range*CDF(x))",Near-optimal entropy coding; approaches H(X) bits per symbol,"{""precision"": ""arithmetic precision bits""}","{""precision"": 16}",O(n),O(1),[3],True,[]
ENTROPY_CODER,Arithmetic Coding,"[low, high) \leftarrow [low + range \cdot CDF(x-1), low + range \cdot CDF(x))","[low, high) = [low + range*CDF(x-1), low + range*CDF(x))",Near-optimal entropy coding; approaches H(X) bits per symbol,"{""precision"": ""arithmetic precision bits""}","{""precision"": 24}",O(n),O(1),[3],True,[]
ENTROPY_CODER,Arithmetic Coding,"[low, high) \leftarrow [low + range \cdot CDF(x-1), low + range \cdot CDF(x))","[low, high) = [low + range*CDF(x-1), low + range*CDF(x))",Near-optimal entropy coding; approaches H(X) bits per symbol,"{""precision"": ""arithmetic precision bits""}","{""precision"": 32}",O(n),O(1),[3],True,[]
ENTROPY_CODER,Arithmetic Coding,"[low, high) \leftarrow [low + range \cdot CDF(x-1), low + range \cdot CDF(x))","[low, high) = [low + range*CDF(x-1), low + range*CDF(x))",Near-optimal entropy coding; approaches H(X) bits per symbol,"{""precision"": ""arithmetic precision bits""}","{""precision"": 64}",O(n),O(1),[3],True,[]
ENTROPY_CODER,Range Coding,range = high - low; \quad high = low + range \cdot p_{cum}(x); \quad low += range \cdot p_{cum}(x-1),"range = high - low; update [low, high) based on cumulative probability",Arithmetic coding variant with byte-aligned output; used in LZMA,{},{},O(n),O(1),[3],True,[]
ENTROPY_CODER,Asymmetric Numeral Systems (ANS),"C(x, s) = \lfloor x/f_s \rfloor \cdot 2^n + CDF(s) + (x \mod f_s)","C(state, symbol) = floor(state/freq) * 2^n + CDF(symbol) + (state mod freq)",Modern entropy coder combining arithmetic efficiency with table-based speed,"{""table_log"": ""log2 of state table size""}","{""table_log"": 9}",O(n),O(2^table_log),[3],True,[]
ENTROPY_CODER,Asymmetric Numeral Systems (ANS),"C(x, s) = \lfloor x/f_s \rfloor \cdot 2^n + CDF(s) + (x \mod f_s)","C(state, symbol) = floor(state/freq) * 2^n + CDF(symbol) + (state mod freq)",Modern entropy coder combining arithmetic efficiency with table-based speed,"{""table_log"": ""log2 of state table size""}","{""table_log"": 10}",O(n),O(2^table_log),[3],True,[]
ENTROPY_CODER,Asymmetric Numeral Systems (ANS),"C(x, s) = \lfloor x/f_s \rfloor \cdot 2^n + CDF(s) + (x \mod f_s)","C(state, symbol) = floor(state/freq) * 2^n + CDF(symbol) + (state mod freq)",Modern entropy coder combining arithmetic efficiency with table-based speed,"{""table_log"": ""log2 of state table size""}","{""table_log"": 11}",O(n),O(2^table_log),[3],True,[]
ENTROPY_CODER,Asymmetric Numeral Systems (ANS),"C(x, s) = \lfloor x/f_s \rfloor \cdot 2^n + CDF(s) + (x \mod f_s)","C(state, symbol) = floor(state/freq) * 2^n + CDF(symbol) + (state mod freq)",Modern entropy coder combining arithmetic efficiency with table-based speed,"{""table_log"": ""log2 of state table size""}","{""table_log"": 12}",O(n),O(2^table_log),[3],True,[]
ENTROPY_CODER,tANS (Tabled ANS),state' = table[state][symbol]; \quad \text{output} = state' \gg \text{bits},new_state = encoding_table[state][symbol]; output overflowing bits,Table-driven ANS for very fast encoding/decoding; used in ZSTD,"{""table_log"": ""log2 of table size""}","{""table_log"": 9}",O(n),O(|Σ| * 2^table_log),[3],True,[]
ENTROPY_CODER,tANS (Tabled ANS),state' = table[state][symbol]; \quad \text{output} = state' \gg \text{bits},new_state = encoding_table[state][symbol]; output overflowing bits,Table-driven ANS for very fast encoding/decoding; used in ZSTD,"{""table_log"": ""log2 of table size""}","{""table_log"": 10}",O(n),O(|Σ| * 2^table_log),[3],True,[]
ENTROPY_CODER,tANS (Tabled ANS),state' = table[state][symbol]; \quad \text{output} = state' \gg \text{bits},new_state = encoding_table[state][symbol]; output overflowing bits,Table-driven ANS for very fast encoding/decoding; used in ZSTD,"{""table_log"": ""log2 of table size""}","{""table_log"": 11}",O(n),O(|Σ| * 2^table_log),[3],True,[]
ENTROPY_CODER,tANS (Tabled ANS),state' = table[state][symbol]; \quad \text{output} = state' \gg \text{bits},new_state = encoding_table[state][symbol]; output overflowing bits,Table-driven ANS for very fast encoding/decoding; used in ZSTD,"{""table_log"": ""log2 of table size""}","{""table_log"": 12}",O(n),O(|Σ| * 2^table_log),[3],True,[]
ENTROPY_CODER,rANS (Range ANS),x' = (x // f_s) \cdot M + CDF(s) + (x \mod f_s),new_state = (state // freq) * total_freq + CDF(symbol) + (state mod freq),Range-based ANS; good for adaptive coding,"{""precision"": ""frequency precision bits""}","{""precision"": 12}",O(n),O(|Σ|),[3],True,[]
ENTROPY_CODER,rANS (Range ANS),x' = (x // f_s) \cdot M + CDF(s) + (x \mod f_s),new_state = (state // freq) * total_freq + CDF(symbol) + (state mod freq),Range-based ANS; good for adaptive coding,"{""precision"": ""frequency precision bits""}","{""precision"": 14}",O(n),O(|Σ|),[3],True,[]
ENTROPY_CODER,rANS (Range ANS),x' = (x // f_s) \cdot M + CDF(s) + (x \mod f_s),new_state = (state // freq) * total_freq + CDF(symbol) + (state mod freq),Range-based ANS; good for adaptive coding,"{""precision"": ""frequency precision bits""}","{""precision"": 16}",O(n),O(|Σ|),[3],True,[]
RUN_LENGTH,Basic RLE,"\text{encode}(s^n) = (n, s)","encode(symbol repeated n times) = (count, symbol)","Replace runs of identical symbols with (count, symbol) pairs","{""max_run"": ""maximum run length""}","{""max_run"": 127}",O(n),O(1),"[2, 3]",True,[]
RUN_LENGTH,Basic RLE,"\text{encode}(s^n) = (n, s)","encode(symbol repeated n times) = (count, symbol)","Replace runs of identical symbols with (count, symbol) pairs","{""max_run"": ""maximum run length""}","{""max_run"": 255}",O(n),O(1),"[2, 3]",True,[]
RUN_LENGTH,Basic RLE,"\text{encode}(s^n) = (n, s)","encode(symbol repeated n times) = (count, symbol)","Replace runs of identical symbols with (count, symbol) pairs","{""max_run"": ""maximum run length""}","{""max_run"": 65535}",O(n),O(1),"[2, 3]",True,[]
RUN_LENGTH,PackBits RLE,\begin{cases} n \geq 0: & n+1 \text{ literal bytes follow} \\ n < 0: & \text{repeat next byte } |n|+1 \text{ times} \end{cases},n >= 0: (n+1) literals follow; n < 0: repeat next byte (|n|+1) times,Apple's RLE variant; efficient for mixed runs and literals,{},{},O(n),O(1),"[2, 3]",True,[]
RUN_LENGTH,Zero RLE,"\text{encode}(0^n) = (\text{ZERO\_TOKEN}, n); \text{ others literal}","encode(n zeros) = (ZERO_TOKEN, count); non-zeros passed through",RLE specialized for runs of zeros; common after BWT+MTF,"{""threshold"": ""minimum zeros to encode""}","{""threshold"": 1}",O(n),O(1),[2],True,"[""Move-to-Front Transform""]"
RUN_LENGTH,Zero RLE,"\text{encode}(0^n) = (\text{ZERO\_TOKEN}, n); \text{ others literal}","encode(n zeros) = (ZERO_TOKEN, count); non-zeros passed through",RLE specialized for runs of zeros; common after BWT+MTF,"{""threshold"": ""minimum zeros to encode""}","{""threshold"": 2}",O(n),O(1),[2],True,"[""Move-to-Front Transform""]"
RUN_LENGTH,Zero RLE,"\text{encode}(0^n) = (\text{ZERO\_TOKEN}, n); \text{ others literal}","encode(n zeros) = (ZERO_TOKEN, count); non-zeros passed through",RLE specialized for runs of zeros; common after BWT+MTF,"{""threshold"": ""minimum zeros to encode""}","{""threshold"": 3}",O(n),O(1),[2],True,"[""Move-to-Front Transform""]"
RUN_LENGTH,Golomb-Rice RLE,"q = \lfloor n/m \rfloor, r = n \mod m; \text{ encode } q \text{ in unary, } r \text{ in binary}",quotient = n // m; remainder = n mod m; output unary(q) + binary(r),Variable-length RLE using Golomb coding; optimal for geometric distribution,"{""m"": ""Golomb divisor (power of 2 for Rice)""}","{""m"": 1}",O(n),O(1),"[2, 3]",True,[]
RUN_LENGTH,Golomb-Rice RLE,"q = \lfloor n/m \rfloor, r = n \mod m; \text{ encode } q \text{ in unary, } r \text{ in binary}",quotient = n // m; remainder = n mod m; output unary(q) + binary(r),Variable-length RLE using Golomb coding; optimal for geometric distribution,"{""m"": ""Golomb divisor (power of 2 for Rice)""}","{""m"": 2}",O(n),O(1),"[2, 3]",True,[]
RUN_LENGTH,Golomb-Rice RLE,"q = \lfloor n/m \rfloor, r = n \mod m; \text{ encode } q \text{ in unary, } r \text{ in binary}",quotient = n // m; remainder = n mod m; output unary(q) + binary(r),Variable-length RLE using Golomb coding; optimal for geometric distribution,"{""m"": ""Golomb divisor (power of 2 for Rice)""}","{""m"": 4}",O(n),O(1),"[2, 3]",True,[]
RUN_LENGTH,Golomb-Rice RLE,"q = \lfloor n/m \rfloor, r = n \mod m; \text{ encode } q \text{ in unary, } r \text{ in binary}",quotient = n // m; remainder = n mod m; output unary(q) + binary(r),Variable-length RLE using Golomb coding; optimal for geometric distribution,"{""m"": ""Golomb divisor (power of 2 for Rice)""}","{""m"": 8}",O(n),O(1),"[2, 3]",True,[]
RUN_LENGTH,Golomb-Rice RLE,"q = \lfloor n/m \rfloor, r = n \mod m; \text{ encode } q \text{ in unary, } r \text{ in binary}",quotient = n // m; remainder = n mod m; output unary(q) + binary(r),Variable-length RLE using Golomb coding; optimal for geometric distribution,"{""m"": ""Golomb divisor (power of 2 for Rice)""}","{""m"": 16}",O(n),O(1),"[2, 3]",True,[]
RUN_LENGTH,Golomb-Rice RLE,"q = \lfloor n/m \rfloor, r = n \mod m; \text{ encode } q \text{ in unary, } r \text{ in binary}",quotient = n // m; remainder = n mod m; output unary(q) + binary(r),Variable-length RLE using Golomb coding; optimal for geometric distribution,"{""m"": ""Golomb divisor (power of 2 for Rice)""}","{""m"": 32}",O(n),O(1),"[2, 3]",True,[]
CONTEXT_MODEL,Context Mixing (Linear),P = \sum_{i} w_i \cdot P_i \text{ where } \sum w_i = 1,P = SUM(weight_i * P_i) where weights sum to 1,Weighted combination of multiple context model predictions,"{""num_models"": ""number of models to mix""}","{""num_models"": 2}",O(n * num_models),O(num_models * model_size),[2],True,[]
CONTEXT_MODEL,Context Mixing (Linear),P = \sum_{i} w_i \cdot P_i \text{ where } \sum w_i = 1,P = SUM(weight_i * P_i) where weights sum to 1,Weighted combination of multiple context model predictions,"{""num_models"": ""number of models to mix""}","{""num_models"": 4}",O(n * num_models),O(num_models * model_size),[2],True,[]
CONTEXT_MODEL,Context Mixing (Linear),P = \sum_{i} w_i \cdot P_i \text{ where } \sum w_i = 1,P = SUM(weight_i * P_i) where weights sum to 1,Weighted combination of multiple context model predictions,"{""num_models"": ""number of models to mix""}","{""num_models"": 8}",O(n * num_models),O(num_models * model_size),[2],True,[]
CONTEXT_MODEL,Context Mixing (Linear),P = \sum_{i} w_i \cdot P_i \text{ where } \sum w_i = 1,P = SUM(weight_i * P_i) where weights sum to 1,Weighted combination of multiple context model predictions,"{""num_models"": ""number of models to mix""}","{""num_models"": 16}",O(n * num_models),O(num_models * model_size),[2],True,[]
CONTEXT_MODEL,Context Mixing (Logistic/PAQ),P = \sigma\left(\sum_i w_i \cdot \text{stretch}(P_i)\right) \text{ where stretch}(p) = \ln\frac{p}{1-p},P = sigmoid(SUM(w_i * ln(P_i / (1 - P_i)))),Logistic mixing in log-odds space; more stable than linear mixing,"{""learning_rate"": ""weight adaptation rate""}","{""learning_rate"": 0.001}",O(n * num_models),O(num_models * model_size),[2],True,[]
CONTEXT_MODEL,Context Mixing (Logistic/PAQ),P = \sigma\left(\sum_i w_i \cdot \text{stretch}(P_i)\right) \text{ where stretch}(p) = \ln\frac{p}{1-p},P = sigmoid(SUM(w_i * ln(P_i / (1 - P_i)))),Logistic mixing in log-odds space; more stable than linear mixing,"{""learning_rate"": ""weight adaptation rate""}","{""learning_rate"": 0.005}",O(n * num_models),O(num_models * model_size),[2],True,[]
CONTEXT_MODEL,Context Mixing (Logistic/PAQ),P = \sigma\left(\sum_i w_i \cdot \text{stretch}(P_i)\right) \text{ where stretch}(p) = \ln\frac{p}{1-p},P = sigmoid(SUM(w_i * ln(P_i / (1 - P_i)))),Logistic mixing in log-odds space; more stable than linear mixing,"{""learning_rate"": ""weight adaptation rate""}","{""learning_rate"": 0.01}",O(n * num_models),O(num_models * model_size),[2],True,[]
CONTEXT_MODEL,Context Mixing (Logistic/PAQ),P = \sigma\left(\sum_i w_i \cdot \text{stretch}(P_i)\right) \text{ where stretch}(p) = \ln\frac{p}{1-p},P = sigmoid(SUM(w_i * ln(P_i / (1 - P_i)))),Logistic mixing in log-odds space; more stable than linear mixing,"{""learning_rate"": ""weight adaptation rate""}","{""learning_rate"": 0.05}",O(n * num_models),O(num_models * model_size),[2],True,[]
CONTEXT_MODEL,Secondary Symbol Estimation (SSE),P' = T[context][discretize(P)],P_adjusted = lookup_table[context][quantized_probability],Table-based probability adjustment; sharpens mixer output,"{""table_bits"": ""bits for probability quantization""}","{""table_bits"": 5}",O(1),O(contexts * 2^table_bits),[2],True,[]
CONTEXT_MODEL,Secondary Symbol Estimation (SSE),P' = T[context][discretize(P)],P_adjusted = lookup_table[context][quantized_probability],Table-based probability adjustment; sharpens mixer output,"{""table_bits"": ""bits for probability quantization""}","{""table_bits"": 6}",O(1),O(contexts * 2^table_bits),[2],True,[]
CONTEXT_MODEL,Secondary Symbol Estimation (SSE),P' = T[context][discretize(P)],P_adjusted = lookup_table[context][quantized_probability],Table-based probability adjustment; sharpens mixer output,"{""table_bits"": ""bits for probability quantization""}","{""table_bits"": 7}",O(1),O(contexts * 2^table_bits),[2],True,[]
CONTEXT_MODEL,Secondary Symbol Estimation (SSE),P' = T[context][discretize(P)],P_adjusted = lookup_table[context][quantized_probability],Table-based probability adjustment; sharpens mixer output,"{""table_bits"": ""bits for probability quantization""}","{""table_bits"": 8}",O(1),O(contexts * 2^table_bits),[2],True,[]
CONTEXT_MODEL,Indirect Context Model,"context = hash(byte_{-1}, byte_{-2}, ..., bit\_pos)","context = hash(previous_bytes, current_bit_position)",Uses hash of recent bytes plus bit position as context,"{""context_bits"": ""bits for context hash""}","{""context_bits"": 16}",O(1),O(2^context_bits),[2],True,[]
CONTEXT_MODEL,Indirect Context Model,"context = hash(byte_{-1}, byte_{-2}, ..., bit\_pos)","context = hash(previous_bytes, current_bit_position)",Uses hash of recent bytes plus bit position as context,"{""context_bits"": ""bits for context hash""}","{""context_bits"": 18}",O(1),O(2^context_bits),[2],True,[]
CONTEXT_MODEL,Indirect Context Model,"context = hash(byte_{-1}, byte_{-2}, ..., bit\_pos)","context = hash(previous_bytes, current_bit_position)",Uses hash of recent bytes plus bit position as context,"{""context_bits"": ""bits for context hash""}","{""context_bits"": 20}",O(1),O(2^context_bits),[2],True,[]
CONTEXT_MODEL,Indirect Context Model,"context = hash(byte_{-1}, byte_{-2}, ..., bit\_pos)","context = hash(previous_bytes, current_bit_position)",Uses hash of recent bytes plus bit position as context,"{""context_bits"": ""bits for context hash""}","{""context_bits"": 22}",O(1),O(2^context_bits),[2],True,[]
CONTEXT_MODEL,Indirect Context Model,"context = hash(byte_{-1}, byte_{-2}, ..., bit\_pos)","context = hash(previous_bytes, current_bit_position)",Uses hash of recent bytes plus bit position as context,"{""context_bits"": ""bits for context hash""}","{""context_bits"": 24}",O(1),O(2^context_bits),[2],True,[]
CONTEXT_MODEL,Match Model,P(bit) = \begin{cases} 0.99 & \text{if match and bit matches} \\ 0.01 & \text{if match and bit differs} \\ 0.5 & \text{no match} \end{cases},"P(bit) = 0.99 if matching_context AND bit_matches, else 0.01 if differs, else 0.5",Predicts based on longest context match in history,"{""min_match"": ""minimum match length""}","{""min_match"": 4}",O(n),O(history_size),[2],True,[]
CONTEXT_MODEL,Match Model,P(bit) = \begin{cases} 0.99 & \text{if match and bit matches} \\ 0.01 & \text{if match and bit differs} \\ 0.5 & \text{no match} \end{cases},"P(bit) = 0.99 if matching_context AND bit_matches, else 0.01 if differs, else 0.5",Predicts based on longest context match in history,"{""min_match"": ""minimum match length""}","{""min_match"": 8}",O(n),O(history_size),[2],True,[]
CONTEXT_MODEL,Match Model,P(bit) = \begin{cases} 0.99 & \text{if match and bit matches} \\ 0.01 & \text{if match and bit differs} \\ 0.5 & \text{no match} \end{cases},"P(bit) = 0.99 if matching_context AND bit_matches, else 0.01 if differs, else 0.5",Predicts based on longest context match in history,"{""min_match"": ""minimum match length""}","{""min_match"": 16}",O(n),O(history_size),[2],True,[]
FILTER,E8/E9 Transform (x86 filter),\text{CALL/JMP}(rel) \rightarrow \text{CALL/JMP}(abs),convert relative x86 CALL/JMP addresses to absolute,Converts relative x86 jump addresses to absolute for better compression,{},{},O(n),O(1),[0],True,[]
FILTER,ARM Filter,\text{BL}(rel) \rightarrow \text{BL}(abs),convert relative ARM branch-link addresses to absolute,Converts relative ARM BL addresses to absolute,{},{},O(n),O(1),[0],True,[]
FILTER,Record Reordering,"interleave(col_1, col_2, ..., col_n) \text{ from } (rec_1, rec_2, ...)","reorder [rec1, rec2, ...] to [col1_values, col2_values, ...]",Reorders columnar data for better locality,"{""record_size"": ""fixed record size in bytes""}","{""record_size"": 4}",O(n),O(n),[0],True,[]
FILTER,Record Reordering,"interleave(col_1, col_2, ..., col_n) \text{ from } (rec_1, rec_2, ...)","reorder [rec1, rec2, ...] to [col1_values, col2_values, ...]",Reorders columnar data for better locality,"{""record_size"": ""fixed record size in bytes""}","{""record_size"": 8}",O(n),O(n),[0],True,[]
FILTER,Record Reordering,"interleave(col_1, col_2, ..., col_n) \text{ from } (rec_1, rec_2, ...)","reorder [rec1, rec2, ...] to [col1_values, col2_values, ...]",Reorders columnar data for better locality,"{""record_size"": ""fixed record size in bytes""}","{""record_size"": 16}",O(n),O(n),[0],True,[]
FILTER,Record Reordering,"interleave(col_1, col_2, ..., col_n) \text{ from } (rec_1, rec_2, ...)","reorder [rec1, rec2, ...] to [col1_values, col2_values, ...]",Reorders columnar data for better locality,"{""record_size"": ""fixed record size in bytes""}","{""record_size"": 32}",O(n),O(n),[0],True,[]
FILTER,Record Reordering,"interleave(col_1, col_2, ..., col_n) \text{ from } (rec_1, rec_2, ...)","reorder [rec1, rec2, ...] to [col1_values, col2_values, ...]",Reorders columnar data for better locality,"{""record_size"": ""fixed record size in bytes""}","{""record_size"": 64}",O(n),O(n),[0],True,[]
FILTER,Record Reordering,"interleave(col_1, col_2, ..., col_n) \text{ from } (rec_1, rec_2, ...)","reorder [rec1, rec2, ...] to [col1_values, col2_values, ...]",Reorders columnar data for better locality,"{""record_size"": ""fixed record size in bytes""}","{""record_size"": 128}",O(n),O(n),[0],True,[]
FILTER,RGB → YCbCr (Lossless),Y = R + G + B; Cb = B - G; Cr = R - G,Y = R + G + B; Cb = B - G; Cr = R - G (reversible integer version),Reversible color space transform; decorrelates image data,{},{},O(n),O(1),[0],True,[]
FILTER,Bit Plane Separation,"planes[i] = (bytes >> i) \& 1 \text{ for } i \in [0, 7]",split bytes into 8 bit planes: plane[i] = all i-th bits,Separates data into bit planes for better entropy coding,{},{},O(n),O(n),[0],True,[]
INTEGER_CODER,Unary Code,U(n) = 1^n 0 \text{ (n ones followed by zero)},U(n) = n ones followed by a zero,Simplest universal code; optimal for geometric(0.5) distribution,{},{},O(n) per integer,O(1),[3],True,[]
INTEGER_CODER,Elias Gamma Code,\gamma(n) = U(\lfloor\log_2 n\rfloor) \cdot bin(n),gamma(n) = unary(floor(log2(n))) + binary(n),Universal code: unary length prefix + binary value,{},{},O(log n) per integer,O(1),[3],True,[]
INTEGER_CODER,Elias Delta Code,\delta(n) = \gamma(\lfloor\log_2 n\rfloor + 1) \cdot bin(n \mod 2^{\lfloor\log_2 n\rfloor}),delta(n) = gamma(floor(log2(n)) + 1) + binary(n mod 2^floor(log2(n))),More efficient than gamma for larger integers,{},{},O(log log n) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 1}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 2}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 3}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 4}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 5}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 6}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 7}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 8}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 10}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 16}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Golomb Code,G_m(n) = U(\lfloor n/m \rfloor) \cdot bin_m(n \mod m),"G_m(n) = unary(n // m) + binary(n mod m, ceil(log2(m)) bits)",Optimal for geometric distribution with parameter p; m ≈ -1/log2(1-p),"{""m"": ""Golomb parameter""}","{""m"": 32}",O(n/m + log m) per integer,O(1),[3],True,[]
INTEGER_CODER,Rice Code,"R_k(n) = U(n >> k) \cdot bin(n \& (2^k - 1), k)",R_k(n) = unary(n >> k) + k lowest bits of n,Golomb code with m = 2^k; simpler and faster,"{""k"": ""Rice parameter (log2 of divisor)""}","{""k"": 0}",O(n >> k + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Rice Code,"R_k(n) = U(n >> k) \cdot bin(n \& (2^k - 1), k)",R_k(n) = unary(n >> k) + k lowest bits of n,Golomb code with m = 2^k; simpler and faster,"{""k"": ""Rice parameter (log2 of divisor)""}","{""k"": 1}",O(n >> k + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Rice Code,"R_k(n) = U(n >> k) \cdot bin(n \& (2^k - 1), k)",R_k(n) = unary(n >> k) + k lowest bits of n,Golomb code with m = 2^k; simpler and faster,"{""k"": ""Rice parameter (log2 of divisor)""}","{""k"": 2}",O(n >> k + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Rice Code,"R_k(n) = U(n >> k) \cdot bin(n \& (2^k - 1), k)",R_k(n) = unary(n >> k) + k lowest bits of n,Golomb code with m = 2^k; simpler and faster,"{""k"": ""Rice parameter (log2 of divisor)""}","{""k"": 3}",O(n >> k + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Rice Code,"R_k(n) = U(n >> k) \cdot bin(n \& (2^k - 1), k)",R_k(n) = unary(n >> k) + k lowest bits of n,Golomb code with m = 2^k; simpler and faster,"{""k"": ""Rice parameter (log2 of divisor)""}","{""k"": 4}",O(n >> k + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Rice Code,"R_k(n) = U(n >> k) \cdot bin(n \& (2^k - 1), k)",R_k(n) = unary(n >> k) + k lowest bits of n,Golomb code with m = 2^k; simpler and faster,"{""k"": ""Rice parameter (log2 of divisor)""}","{""k"": 5}",O(n >> k + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Rice Code,"R_k(n) = U(n >> k) \cdot bin(n \& (2^k - 1), k)",R_k(n) = unary(n >> k) + k lowest bits of n,Golomb code with m = 2^k; simpler and faster,"{""k"": ""Rice parameter (log2 of divisor)""}","{""k"": 6}",O(n >> k + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Exponential Golomb,"Exp(n, k) = \gamma(1 + (n >> k)) \cdot bin(n \& (2^k-1), k)","ExpGolomb(n, k) = gamma(1 + (n >> k)) + k lowest bits",Used in H.264/AVC video coding,"{""k"": ""order parameter""}","{""k"": 0}",O(log(n >> k) + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Exponential Golomb,"Exp(n, k) = \gamma(1 + (n >> k)) \cdot bin(n \& (2^k-1), k)","ExpGolomb(n, k) = gamma(1 + (n >> k)) + k lowest bits",Used in H.264/AVC video coding,"{""k"": ""order parameter""}","{""k"": 1}",O(log(n >> k) + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Exponential Golomb,"Exp(n, k) = \gamma(1 + (n >> k)) \cdot bin(n \& (2^k-1), k)","ExpGolomb(n, k) = gamma(1 + (n >> k)) + k lowest bits",Used in H.264/AVC video coding,"{""k"": ""order parameter""}","{""k"": 2}",O(log(n >> k) + k) per integer,O(1),[3],True,[]
INTEGER_CODER,Exponential Golomb,"Exp(n, k) = \gamma(1 + (n >> k)) \cdot bin(n \& (2^k-1), k)","ExpGolomb(n, k) = gamma(1 + (n >> k)) + k lowest bits",Used in H.264/AVC video coding,"{""k"": ""order parameter""}","{""k"": 3}",O(log(n >> k) + k) per integer,O(1),[3],True,[]
INTEGER_CODER,VByte / Varint,\text{VByte}(n) = \text{7 bits data + 1 continuation bit per byte},VByte(n) = sequence of 7-bit chunks with high-bit continuation flag,Simple variable-byte integer encoding; used in Protocol Buffers,{},{},O(log n / 7) per integer,O(1),[3],True,[]
