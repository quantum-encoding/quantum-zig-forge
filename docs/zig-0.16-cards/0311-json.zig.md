# Migration Card: std.json

## 1) Concept

This file is the main entry point for Zig's JSON parsing and serialization library, implementing RFC 8259 compliance. It provides a multi-layered API with low-level token scanning via `Scanner` and high-level parsing/serialization functions. The library supports both static parsing into Zig types and dynamic parsing into a generic `Value` type for runtime inspection.

Key components include the `Scanner` for token-level parsing, `parseFromSlice` for deserializing JSON into Zig types, `Stringify` for serialization, and `Value` for dynamic JSON representation. The API supports both streaming and complete input processing patterns.

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **Factory functions require explicit allocators**: `parseFromSlice` and `Scanner.initCompleteInput` now require allocator parameters
- **Memory management**: Returned `Parsed` structs must be explicitly deinitialized with `.deinit()`
- **Leaky variants**: `parseFromSliceLeaky` provides alternative memory management strategy

### I/O Interface Changes
- **Writer-based serialization**: `Stringify` uses dependency injection with `std.Io.Writer` interface
- **Streaming API**: `Stringify` provides `beginObject`, `objectField`, `write`, `endObject` methods for incremental serialization
- **Generic reader support**: `Reader` connects `std.Io.GenericReader` to `Scanner`

### Error Handling Changes
- **Specific error types**: `ParseError`, `ParseFromValueError`, and `Scanner.Error` provide detailed error categorization
- **Result types**: Functions return `Parsed(T)` or specific error unions rather than generic error sets

### API Structure Changes
- **Parsed wrapper**: `parseFromSlice` returns `Parsed(T)` containing both value and parsing context instead of raw value
- **Configuration objects**: `ParseOptions` and `Stringify.Options` provide structured configuration
- **Formatter pattern**: `fmt()` function provides std.fmt-compatible formatting interface

## 3) The Golden Snippet

```zig
const std = @import("std");
const json = std.json;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();

    // Parse JSON into a struct with default values
    const T = struct { 
        a: i32 = -1, 
        b: [2]u8 
    };
    
    var parsed = try json.parseFromSlice(T, allocator, "{\"b\":\"xy\"}", .{});
    defer parsed.deinit();
    
    std.debug.print("a: {}\n", .{parsed.value.a}); // Uses default: -1
    std.debug.print("b: {s}\n", .{parsed.value.b});
}
```

## 4) Dependencies

- **std.mem** - Memory allocation and management
- **std.io** - I/O interfaces for readers and writers  
- **std.fmt** - Formatting utilities
- **std.testing** - Testing infrastructure
- **std.heap** - Allocator implementations (indirect)

The module has extensive internal structure with submodules for dynamic types (`json/dynamic.zig`), static parsing (`json/static.zig`), scanning (`json/Scanner.zig`), and serialization (`json/Stringify.zig`).