# Migration Card: std/crypto/blake2.zig

## 1) Concept

This file implements the BLAKE2 cryptographic hash function family for Zig's standard library. It provides both BLAKE2s (optimized for 8-32 bit platforms) and BLAKE2b (optimized for 64-bit platforms) variants with configurable output sizes. The implementation supports both one-shot hashing and streaming interfaces, with optional keyed hashing, salt, and context parameters.

Key components include:
- Generic `Blake2s` and `Blake2b` types parameterized by output bit size
- Pre-defined common variants (Blake2s128, Blake2s256, Blake2b256, Blake2b512, etc.)
- Streaming API with `init`, `update`, and `final` methods
- One-shot `hash` function for simple use cases
- Support for keyed hashing, salt, and context parameters through options struct

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **No allocator dependency**: Both BLAKE2 implementations are entirely allocation-free. The state is stored inline in the struct, and all operations work on stack-allocated buffers.
- **No factory functions**: The API uses direct struct initialization via `init()` rather than factory patterns.

### I/O Interface Changes
- **Streaming interface consistency**: The `update`/`final` pattern remains stable, taking slices and output buffers directly without requiring stream abstractions.
- **No dependency injection**: The hashing operations are self-contained without external I/O dependencies.

### Error Handling Changes
- **No error returns**: All public functions (`init`, `update`, `final`, `hash`) return `void` rather than error sets. Errors are handled via debug assertions for parameter validation.
- **Compile-time validation**: Output bit sizes are validated at compile time with `debug.assert`.

### API Structure Changes
- **Options struct pattern**: Configuration uses a structured `Options` type with default values rather than multiple parameters:
  ```zig
  pub const Options = struct { 
      key: ?[]const u8 = null, 
      salt: ?[8]u8 = null, 
      context: ?[8]u8 = null, 
      expected_out_bits: usize = out_bits 
  };
  ```
- **Consistent initialization**: Both streaming and one-shot APIs use the same `Options` pattern.

## 3) The Golden Snippet

```zig
const std = @import("std");
const Blake2s256 = std.crypto.Blake2s256;

// One-shot hashing with default options
var output: [32]u8 = undefined;
Blake2s256.hash("hello world", &output, .{});

// Streaming interface with custom options
var hasher = Blake2s256.init(.{
    .key = "secret_key",
    .salt = [_]u8{0x42} ** 8,
});
hasher.update("hello");
hasher.update(" world");
hasher.final(&output);

// Keyed hashing
Blake2s256.hash("message", &output, .{ .key = "my_key" });
```

## 4) Dependencies

- `std.mem` - For memory operations (`readInt`, `nativeToLittle`, `@memset`)
- `std.math` - For bit rotation operations (`rotr`)
- `std.debug` - For compile-time assertions
- `@import("test.zig")` - For internal testing only

**Note**: This implementation has minimal dependencies and is designed to be self-contained within the crypto module, making it suitable for environments with restricted standard library access.