# Migration Card: UEFI File Protocol

## 1) Concept

This file implements the UEFI File Protocol interface, which provides file I/O operations in a UEFI (Unified Extensible Firmware Interface) environment. The protocol defines a structured interface for file operations including opening, closing, reading, writing, seeking, and file metadata management. Key components include the main `File` extern struct that wraps UEFI function pointers, comprehensive error sets for different operations, file opening modes, file attributes, and file information structures.

The implementation provides a Zig-friendly wrapper around the low-level UEFI C-style interface, translating status codes to Zig error unions and providing type-safe access to file operations. It supports three types of file information structures (File, FileSystem, and VolumeLabel) through a tagged union interface.

## 2) The 0.11 vs 0.16 Diff

**No major migration changes detected** - this appears to be a stable UEFI interface wrapper that follows consistent patterns:

- **No allocator dependencies**: All operations work with pre-allocated buffers or return allocated file handles from UEFI
- **Stable error handling**: Uses specific error sets per operation (`OpenError`, `ReadError`, `WriteError`, etc.) rather than generic errors
- **Consistent API structure**: Factory pattern using `open()` method on existing file handles, no `init` vs `open` dichotomy
- **I/O interface**: Direct UEFI protocol calls, no dependency injection of I/O interfaces

The interface maintains the same function signatures and patterns that would have been present in 0.11, focusing on translating UEFI status codes to Zig error unions with comprehensive error coverage.

## 3) The Golden Snippet

```zig
const uefi = std.os.uefi;
const File = uefi.protocol.File;

// Assuming we have a root directory file handle
fn readFileContents(root_dir: *const File, file_path: [*:0]const u16) !void {
    // Open file for reading
    var file = try root_dir.open(file_path, .read, .{});
    defer file.close() catch {};

    // Read file contents
    var buffer: [1024]u8 = undefined;
    const bytes_read = try file.read(&buffer);
    
    // Use the read data...
    const file_data = buffer[0..bytes_read];
}
```

## 4) Dependencies

- `std.os.uefi` - Core UEFI types and utilities
- `std.mem` - Used for string operations in `setInfo`
- `std.meta` - Used for reflection in `getInfo` and `setInfo`

The file has minimal external dependencies, primarily relying on the UEFI subsystem and basic memory utilities, making it a stable foundation for UEFI file operations.