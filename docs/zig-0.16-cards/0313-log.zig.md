# Migration Card: std/log.zig

## 1) Concept

This file provides Zig's standardized logging interface that allows programs and libraries to emit log messages with configurable formatting and filtering. The key components include:

- **Log Levels**: Four severity levels (err, warn, info, debug) with default level selection based on build mode
- **Scoped Logging**: Support for contextual logging through scoped namespaces using enum literals
- **Customizable Backend**: A pluggable logging implementation via `std.options.logFn`
- **Default Implementation**: A built-in logger that outputs colored messages to stderr with TTY detection

The interface enables both library authors (via scoped logging) and application developers to emit structured log messages that can be filtered by scope and level at compile time.

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **No allocator dependencies**: The logging functions are entirely allocation-free, using stack buffers for formatting
- **Compile-time configuration**: Log levels and scopes are resolved at compile time through `std.options`

### I/O Interface Changes  
- **Dependency injection**: Logging backend is injected via `std.options.logFn` rather than direct function calls
- **Locked stderr writer**: The default implementation uses `std.debug.lockStderrWriter()` for thread-safe output
- **TTY configuration**: Automatic color detection through `std.io.tty.Config` integration

### Error Handling Changes
- **Void functions**: All logging functions return `void` - errors in the logging backend are silently ignored
- **No error propagation**: The design assumes logging should not fail the main application

### API Structure Changes
- **Scoped factory pattern**: `std.log.scoped(.scope)` creates scoped logging namespaces
- **Compile-time level checking**: `logEnabled()` function for conditional compilation based on log settings
- **Enum-driven configuration**: Uses `ScopeLevel` structs for per-scope log level configuration

## 3) The Golden Snippet

```zig
const std = @import("std");
const log = std.log.scoped(.my_library);

pub fn main() void {
    // Using scoped logging
    log.err("Database connection failed: {s}", .{"connection timeout"});
    log.info("Server started on port {}", .{8080});
    
    // Using default scope
    std.log.warn("Low memory condition detected", .{});
    
    // Conditional debug logging
    if (comptime std.log.logEnabled(.debug, .my_library)) {
        log.debug("Internal state: {}", .{some_complex_state});
    }
}
```

## 4) Dependencies

- **std.debug**: For `lockStderrWriter`/`unlockStderrWriter` and TTY configuration
- **std.options**: For `logFn`, `log_level`, and `log_scope_levels` configuration
- **builtin**: For build mode detection to set `default_level`
- **std.io.tty**: Implicitly used for color output in default logger

The module has minimal dependencies and is designed to be lightweight, with most functionality resolved at compile time.