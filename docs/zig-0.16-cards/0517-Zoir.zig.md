# Migration Card: Zig Object Intermediate Representation (Zoir)

## 1) Concept

This file defines the Zig Object Intermediate Representation (ZOIR), which is a simplified Abstract Syntax Tree (AST) for the Zig Object Notation (ZON) format. ZOIR serves as an intermediate representation between the full Zig AST and the ZON serialization format, providing a structured way to represent Zig object literals like arrays, structs, and various literal types (integers, floats, strings, etc.).

Key components include:
- **Node system**: A union type representing different ZON literal types with efficient storage representation
- **Memory management**: Deinitialization functions for cleaning up allocated resources
- **Error handling**: Compile error storage with associated notes for ZON parsing/validation
- **Serialization**: Header structure for file storage with stat information for caching

## 2) The 0.11 vs 0.16 Diff

**Explicit Allocator Requirements:**
- `deinit(zoir: Zoir, gpa: Allocator) void` - Explicit allocator parameter required for cleanup
- `nodes.deinit(gpa)` - MultiArrayList cleanup requires allocator
- Memory is explicitly freed from the provided allocator rather than using implicit/global allocators

**API Structure Changes:**
- No factory functions - Zoir instances appear to be constructed elsewhere (likely by ZonGen)
- Clean separation between representation (Node.Repr) and interpreted values (Node)
- Index-based access pattern with explicit context passing (`get(idx: Index, zoir: Zoir)`)

**Error Handling:**
- Compile errors stored as structured data rather than returned from functions
- `hasCompileErrors()` returns boolean, errors accessed via direct field access
- Error notes stored in parallel array with index-based relationships

## 3) The Golden Snippet

```zig
const std = @import("std");
const Zoir = std.zig.Zoir;

// Assume we have a Zoir instance from ZonGen or file loading
var zoir: Zoir = ...;
const allocator = std.heap.page_allocator;

// Check for compilation errors before processing
if (zoir.hasCompileErrors()) {
    for (zoir.compile_errors) |err| {
        const msg = err.msg.get(zoir);
        // Handle compile error...
    }
} else {
    // Access the root node and traverse the ZOIR tree
    const root_node = Zoir.Node.Index.root.get(zoir);
    
    // Example: Process an array literal
    if (root_node == .array_literal) {
        const array_range = root_node.array_literal;
        for (0..array_range.len) |i| {
            const elem_index = array_range.at(@intCast(i));
            const elem_node = elem_index.get(zoir);
            // Process each element...
        }
    }
}

// Clean up when done
zoir.deinit(allocator);
```

## 4) Dependencies

- `std.mem` - For `Allocator` type and memory operations
- `std.math.big` - For big integer support (`Limb` type)
- `std.debug` - For `assert` debugging support
- `std.zig.Ast` - For AST node indexing and token references
- `std.fs.File` - For file stat information in header

The dependency graph shows this is a core data structure module that bridges between the compiler's AST system and serialization formats, with dependencies on memory management, mathematical types, and file system operations.