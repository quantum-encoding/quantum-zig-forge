# Migration Card: std/hash/Adler32.zig

## 1) Concept
This file implements the Adler-32 checksum algorithm, which is a simple rolling checksum commonly used in zlib compression. The module provides both incremental and one-shot hashing capabilities through a stateful `Adler32` struct and utility functions.

Key components:
- `Adler32` struct that maintains checksum state with default initialization
- `permute()` function that computes the core algorithm given a previous state and input bytes
- `update()` method for incremental hashing by updating an existing Adler32 instance
- `hash()` function for one-shot checksum computation from raw bytes

## 2) The 0.11 vs 0.16 Diff

**No breaking API changes detected** - This module maintains stable, allocation-free patterns:

- **No allocator requirements**: All functions operate on existing data without memory allocation
- **No I/O interface changes**: Pure computational functions without file/stream dependencies  
- **No error handling changes**: All functions return simple values (u32) without error sets
- **API structure unchanged**: Uses consistent state-based pattern with default initialization

The public API remains compatible:
- `Adler32` struct with public `adler` field and default value
- `permute(state, input)` function signature unchanged
- `update(self, input)` method signature unchanged  
- `hash(input)` function signature unchanged

## 3) The Golden Snippet

```zig
const std = @import("std");
const Adler32 = std.hash.Adler32;

// One-shot hashing
const checksum = Adler32.hash("example");
std.debug.print("Checksum: 0x{x}\n", .{checksum});

// Incremental hashing
var hasher = Adler32{};
hasher.update("ex");
hasher.update("am");
hasher.update("ple");
std.debug.print("Incremental checksum: 0x{x}\n", .{hasher.adler});
```

## 4) Dependencies
- `std.testing` - Used exclusively for test validation
- No heavy stdlib dependencies (self-contained algorithm implementation)

**Migration Impact: LOW** - No API changes required for 0.16 migration.