# Migration Card: std/compress/lzma.zig

## 1) Concept

This file implements LZMA (Lempel-Ziv-Markov chain algorithm) decompression functionality for Zig's standard library. It provides a complete streaming decompressor that can handle LZMA-compressed data with configurable dictionary sizes and compression parameters. The main components include:

- **RangeDecoder**: Handles the arithmetic decoding operations for the compressed bitstream
- **Decode**: Core LZMA decoder that maintains state, probabilities, and handles literal/match decoding
- **Decompress**: High-level streaming decompressor that implements the `std.io.Reader` interface
- **CircularBuffer**: Manages the sliding dictionary window for LZ77 operations

The implementation supports both fixed and variable unpacked sizes, configurable memory limits, and various LZMA property configurations (lc, lp, pb parameters).

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **Factory functions require explicit allocators**: `Decode.init()` takes `gpa: Allocator` as first parameter
- **Resource management**: `Decode.deinit()` and `CircularBuffer.deinit()` require allocator parameter for cleanup
- **Dynamic allocation**: `Vec2d.init()` takes allocator for 2D probability table allocation

### I/O Interface Changes
- **Reader/Writer dependency injection**: All operations take `*Reader` and `*Writer` parameters explicitly
- **Streaming design**: `Decompress` implements `std.io.Reader` interface rather than operating on byte slices
- **Counting support**: Most operations accept `n_read: *u64` parameter to track bytes consumed

### Error Handling Changes
- **Specific error sets**: `Decompress.Error` defines comprehensive error types including `OutOfMemory`, `CorruptInput`, `DecompressedSizeMismatch`
- **Error propagation**: Functions return concrete error unions rather than generic error types

### API Structure Changes
- **Multiple initialization paths**: `Decompress.initParams()` and `Decompress.initOptions()` provide different configuration approaches
- **Buffer ownership**: `Decompress.takeBuffer()` allows reclaiming output buffer after processing
- **State machine design**: `process()` returns `ProcessingStatus` enum for flow control

## 3) The Golden Snippet

```zig
const std = @import("std");
const lzma = std.compress.lzma;

pub fn decompressLzmaData(allocator: std.mem.Allocator, input: []const u8, output: []u8) !void {
    var fixed_buffer_stream = std.io.fixedBufferStream(input);
    const reader = fixed_buffer_stream.reader();
    
    var decompressor = try lzma.Decompress.initOptions(
        reader,
        allocator,
        output,
        .{ .unpacked_size = .read_from_header },
        std.math.maxInt(usize)
    );
    defer decompressor.deinit();
    
    // Read decompressed data
    var total_read: usize = 0;
    while (total_read < output.len) {
        const n = try decompressor.reader.read(output[total_read..]);
        if (n == 0) break;
        total_read += n;
    }
}
```

## 4) Dependencies

- **std.mem** - Memory allocation and management
- **std.math** - Mathematical operations and overflow checking
- **std.ArrayList** - Dynamic array management for circular buffer
- **std.io.Reader/Writer** - Core I/O interfaces for streaming
- **std.debug.assert** - Runtime assertions for validation

The implementation heavily relies on the standard I/O interfaces and memory allocation patterns, making it dependent on Zig's core memory and I/O subsystems.