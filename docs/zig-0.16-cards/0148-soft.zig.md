# Migration Card: `std/crypto/aes/soft.zig`

## 1) Concept

This file implements a software-based AES (Advanced Encryption Standard) encryption and decryption module. It provides a complete AES implementation including block operations, key scheduling, and encryption/decryption contexts for both AES-128 and AES-256. The implementation includes side-channel attack mitigations through configurable lookup table access patterns and supports both single-block and parallel block operations.

Key components include:
- `Block`: A single AES block (16 bytes) with encryption/decryption operations
- `BlockVec`: A vector of AES blocks for parallel processing
- `AesEncryptCtx`/`AesDecryptCtx`: Context types for encryption and decryption operations
- `Aes128`/`Aes256`: Convenience types for specific AES variants with standard key schedules

## 2) The 0.11 vs 0.16 Diff

This file demonstrates several Zig 0.16 patterns:

**Explicit Type Construction vs Factory Functions:**
- Uses direct struct initialization: `Block{ .repr = Repr{ s0, s1, s2, s3 } }`
- Context creation via `init` functions: `AesEncryptCtx(Aes128).init(key)`

**Comptime Generic Patterns:**
- Heavy use of comptime parameters: `BlockVec(comptime blocks_count)`, `encryptWide(comptime count: usize, ...)`
- Type functions that return types: `fn AesEncryptCtx(comptime Aes: type) type`

**Error Handling:**
- No error returns in this API - all operations are deterministic and cannot fail
- Uses compile-time assertions: `std.debug.assert(Aes.key_bits == 128 or Aes.key_bits == 256)`

**API Structure:**
- Consistent `init` pattern for context creation
- `fromBytes`/`toBytes` conversion methods instead of implicit conversions
- Separate protected vs unprotected operations for side-channel security

## 3) The Golden Snippet

```zig
const std = @import("std");
const aes_soft = std.crypto.aes.soft;

// AES-128 encryption example
pub fn main() void {
    const key = [16]u8{0x00} ** 16; // 128-bit key
    const plaintext = [16]u8{0x01} ** 16;
    
    var ctx = aes_soft.Aes128.initEnc(key);
    var ciphertext: [16]u8 = undefined;
    ctx.encrypt(&ciphertext, &plaintext);
    
    // ciphertext now contains encrypted data
}
```

## 4) Dependencies

- `std.mem` - For memory operations and integer reading/writing
- `std.math` - For bit rotation and mathematical operations
- `std.atomic` - For cache line size in side-channel mitigations
- `std.options` - For side channel mitigation configuration

The module is self-contained for cryptographic operations and doesn't require external allocators or I/O interfaces.