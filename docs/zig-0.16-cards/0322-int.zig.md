# Zig Big Integer Migration Analysis

## 1) Concept

This file implements arbitrary-precision integer arithmetic for Zig's standard library. It provides three main types for working with big integers:

- **`Mutable`**: A big integer with fixed mutable limb storage, suitable for stack allocation and known-size operations
- **`Const`**: An immutable view into big integer limbs, used for function parameters and temporary values  
- **`Managed`**: A heap-allocated big integer that dynamically grows as needed, with automatic memory management

The implementation supports all standard arithmetic operations, bit manipulation, conversions to/from primitive types, string formatting, and advanced operations like GCD, exponentiation, and square roots.

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **`Managed` type now stores allocator internally**: The `Managed` struct has an `allocator: Allocator` field that persists for the lifetime of the object
- **Factory functions require allocator**: `Managed.init()`, `Managed.initSet()`, `Managed.initCapacity()` all take allocator parameters
- **Memory management methods**: `Managed.ensureCapacity()`, `Managed.clone()`, `Managed.deinit()` use the stored allocator

### I/O Interface Changes
- **Format interface uses `std.Io.Writer`**: The `format()` and `formatNumber()` methods for all three types take a `*std.Io.Writer` parameter
- **String conversion allocates**: `toStringAlloc()` methods require explicit allocator parameter for output memory

### Error Handling Changes
- **Specific error sets**: `ConvertError` enum with `NegativeIntoUnsigned` and `TargetTooSmall` variants
- **Allocator errors**: Most `Managed` methods return `Allocator.Error` for memory allocation failures
- **Input validation**: `setString()` returns `error{InvalidCharacter}` for malformed input

### API Structure Changes
- **Explicit buffer requirements**: Functions like `setString()`, `mul()`, `divFloor()` require pre-allocated limb buffers with sizes calculated by helper functions (`calcMulLimbsBufferLen`, `calcDivLimbsBufferLen`, etc.)
- **Alias control**: `mulNoAlias()` vs `mul()` with explicit aliasing handling through buffer parameters
- **Twos-complement operations**: New methods like `addWrap()`, `addSat()`, `truncate()`, `saturate()` for fixed-width integer semantics

## 3) The Golden Snippet

```zig
const std = @import("std");
const BigInt = std.math.big.int;

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    // Create two big integers
    var a = try BigInt.Managed.initSet(allocator, 12345678901234567890);
    defer a.deinit();
    
    var b = try BigInt.Managed.initSet(allocator, 9876543210987654321);
    defer b.deinit();

    // Perform multiplication
    var result = try BigInt.Managed.init(allocator);
    defer result.deinit();
    try result.mul(&a, &b);

    // Format and print
    const str = try result.toString(allocator, 10, .lower);
    defer allocator.free(str);
    std.debug.print("Result: {s}\n", .{str});
}
```

## 4) Dependencies

- **`std.mem`**: Memory operations, allocator interface, slice manipulation
- **`std.math`**: Mathematical constants and utility functions
- **`std.debug`**: Assertions for contract checking
- **`std.builtin`**: Type system information (Endian, Signedness)
- **`std.fmt`**: Number formatting and digit conversion
- **`std.array_list`**: Temporary storage management in GCD operations

The implementation is heavily dependent on limb-based arithmetic with careful memory management, making `std.mem` the most critical dependency.