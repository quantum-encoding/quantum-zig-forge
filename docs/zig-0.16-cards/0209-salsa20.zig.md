# Migration Analysis: `std/crypto/salsa20.zig`

## 1) Concept

This file implements the Salsa20 and XSalsa20 stream ciphers along with higher-level authenticated encryption constructions. It provides multiple cryptographic primitives:

- **Salsa20** and **XSalsa20**: Core stream ciphers with 20 rounds that perform XOR operations between a keystream and plaintext
- **XSalsa20Poly1305**: Authenticated encryption combining XSalsa20 with Poly1305 MAC
- **SecretBox**: NaCl-compatible symmetric authenticated encryption
- **Box**: NaCl-compatible public-key authenticated encryption using X25519 key exchange
- **SealedBox**: libsodium-compatible anonymous public-key encryption

The implementation includes both vectorized (x86_64) and non-vectorized versions for performance optimization, with the core salsa operations implemented using Zig's SIMD vector types.

## 2) The 0.11 vs 0.16 Diff

This file shows minimal migration impact from Zig 0.11 to 0.16 patterns:

- **No explicit allocator requirements**: All operations work directly on provided buffers without memory allocation
- **No I/O interface changes**: Pure cryptographic operations without file/network I/O
- **Error handling consistency**: Uses specific error types (`AuthenticationError`, `IdentityElementError`, `WeakPublicKeyError`) rather than generic errors
- **API structure**: Maintains simple functional patterns without init/deinit lifecycle

Key public API signatures remain stable:
- `Salsa20.xor(out, in, counter, key, nonce)`
- `XSalsa20.xor(out, in, counter, key, nonce)` 
- `XSalsa20Poly1305.encrypt/decrypt()`
- `SecretBox.seal/open()`
- `Box.seal/open()`
- `SealedBox.seal/open()`

The only notable change is the use of explicit error sets in public-key operations rather than catch-all error types.

## 3) The Golden Snippet

```zig
const std = @import("std");
const crypto = std.crypto;

// Symmetric encryption using SecretBox
var msg: [100]u8 = "Hello, world!".*;
var key: [crypto.SecretBox.key_length]u8 = undefined;
var nonce: [crypto.SecretBox.nonce_length]u8 = undefined;
var encrypted: [msg.len + crypto.SecretBox.tag_length]u8 = undefined;
var decrypted: [msg.len]u8 = undefined;

// Generate random key and nonce
crypto.random.bytes(&key);
crypto.random.bytes(&nonce);

// Encrypt
crypto.SecretBox.seal(&encrypted, &msg, nonce, key);

// Decrypt  
try crypto.SecretBox.open(&decrypted, &encrypted, nonce, key);
```

## 4) Dependencies

- `std.mem` - Memory operations and byte manipulation
- `std.math` - Bit rotation operations
- `std.crypto.onetimeauth.Poly1305` - Authentication
- `std.crypto.hash.blake2.Blake2b` - Hashing for sealed boxes
- `std.crypto.dh.X25519` - Key exchange for Box API
- `std.crypto.errors` - Error type definitions
- `std.crypto.timing_safe` - Constant-time comparisons
- `std.crypto.random` - Random number generation (in tests)
- `std.debug` - Assertions

The dependency graph shows this module integrates with multiple other crypto primitives while maintaining clean separation of concerns.