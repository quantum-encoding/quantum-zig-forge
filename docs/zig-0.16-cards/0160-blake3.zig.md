# Migration Card: `std/crypto/blake3.zig`

## 1) Concept
This file implements the BLAKE3 cryptographic hash function in Zig. BLAKE3 is a high-performance hash function that produces a 256-bit digest by default but supports extendable output (XOF). The implementation provides both sequential and parallel hashing capabilities, with automatic SIMD optimization for better performance. Key components include chunk processing, Merkle tree construction for parallel hashing, and support for keyed hashing and key derivation.

The implementation is structured around three main state types: `Blake3` (main hasher), `ChunkState` (handles individual 1KB chunks), and `Output` (finalizes hash output). It supports both standard hashing and key derivation functions (KDF) with context strings.

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **Parallel hashing requires allocator**: `hashParallel()` now takes an explicit `std.mem.Allocator` parameter
- **No allocator in sequential API**: Regular `init()`, `update()`, `final()` methods remain allocation-free
- **Factory functions with options**: `init()` and `initKdf()` use options structs rather than multiple parameters

### I/O Interface Changes
- **Dependency injection for async I/O**: `hashParallel()` requires `Io` parameter for thread pool management
- **Parallel processing uses I/O groups**: Internal `buildMerkleTreeLayerParallel()` uses `Io.Group` for async operations

### Error Handling Changes
- **Parallel API can fail**: `hashParallel()` returns error union due to potential allocation failures
- **Sequential API remains infallible**: Standard hashing operations don't return errors

### API Structure Changes
- **Options structs for initialization**: `Options` and `KdfOptions` structs replace multiple parameters
- **Explicit seek support**: `finalizeSeek()` method added for XOF functionality
- **Parallel threshold**: Automatic fallback to sequential for small inputs (< 3 MiB)

## 3) The Golden Snippet

```zig
const std = @import("std");
const Blake3 = std.crypto.Blake3;

// Sequential hashing
var hasher = Blake3.init(.{});
hasher.update("hello");
var hash: [32]u8 = undefined;
hasher.final(&hash);

// Keyed hashing
const key: [32]u8 = "whats the Elvish word for friend".*;
var keyed_hasher = Blake3.init(.{ .key = key });
keyed_hasher.update("hello");
keyed_hasher.final(&hash);

// Key derivation
var kdf = Blake3.initKdf("my_app_context", .{});
kdf.update("input_material");
kdf.final(&hash);

// Parallel hashing (for large inputs)
const allocator = std.heap.page_allocator;
try Blake3.hashParallel(large_data, &hash, .{}, allocator, std.io);

// Extendable output
var xof_output: [100]u8 = undefined;
hasher.finalizeSeek(0, &xof_output);
```

## 4) Dependencies
- `std.mem` - Memory operations and allocation
- `std.math` - Bit rotation operations
- `std.simd` - SIMD vector optimization
- `std.Thread` - CPU count detection for parallel processing
- `std.Io` - Asynchronous I/O for parallel hashing
- `std.fmt` - Hexadecimal formatting (tests only)