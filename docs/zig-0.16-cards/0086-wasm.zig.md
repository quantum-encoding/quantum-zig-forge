# Migration Card: `std/Target/wasm.zig`

## 1) Concept

This file defines WebAssembly (WASM) target-specific CPU features and models for the Zig compiler. It's an auto-generated file that enumerates various WASM features like atomics, SIMD, exception handling, and memory operations. The file provides:

- An enum of all available WASM CPU features with their LLVM names and descriptions
- Feature set utility functions for working with combinations of features
- Predefined CPU models (bleeding_edge, generic, lime1, mvp) with their respective feature sets

This is part of Zig's cross-compilation infrastructure, allowing developers to specify target-specific WASM capabilities when compiling code.

## 2) The 0.11 vs 0.16 Diff

This file contains **no public function signatures** that require migration from Zig 0.11 patterns. The API consists entirely of:

- **Enum definitions** (`Feature`) - no breaking changes
- **Compile-time computed arrays** (`all_features`) - no runtime API
- **Struct literals** (`cpu` models) - no function calls
- **Generic feature set utilities** - these are template-generated and don't expose allocator-dependent APIs

The utilities like `featureSet`, `featureSetHas`, etc. are generated by `CpuFeature.FeatureSetFns(Feature)` and work with compile-time feature sets, requiring no allocators or I/O interfaces.

## 3) The Golden Snippet

```zig
const std = @import("std");
const wasm_features = std.Target.wasm.Feature;

// Check if a CPU model supports specific WASM features
const cpu_model = std.Target.wasm.cpu.bleeding_edge;

// Use feature set utilities (compile-time only)
const has_simd = std.Target.wasm.featureSetHas(cpu_model.features, wasm_features.simd128);
const has_atomics = std.Target.wasm.featureSetHas(cpu_model.features, wasm_features.atomics);

// The bleeding_edge model includes many modern WASM features
std.debug.print("SIMD128 supported: {}\n", .{has_simd});
std.debug.print("Atomics supported: {}\n", .{has_atomics});
```

## 4) Dependencies

- `std.Target.Cpu.Feature` - Core CPU feature handling
- `std.Target.Cpu.Model` - CPU model definitions
- `std.debug` - For assertions in compile-time blocks

This is a leaf node in the dependency graph with minimal imports, primarily relying on the core target infrastructure.