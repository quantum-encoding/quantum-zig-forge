# Migration Card: `std/crypto/ff.zig`

## 1) Concept

This file provides allocation-free, constant-time finite field arithmetic for large integers, designed specifically for cryptographic operations. It implements modular arithmetic with side-channel attack mitigations, supporting operations like addition, subtraction, multiplication, exponentiation, and Montgomery form conversions. The key components are:

- **`Uint(max_bits)`**: A fixed-size big integer type with constant-time operations
- **`Modulus(max_bits)`**: Represents a finite field modulus with field element operations
- **`Fe`**: Field elements within a modulus-defined finite field

The implementation is ported from Go's crypto/internal/bigmod and BearSSL, focusing on cryptographic safety through constant-time execution and canonical form enforcement.

## 2) The 0.11 vs 0.16 Diff

**No explicit allocator requirements**: The API is allocation-free by design, using fixed-size buffers and comptime parameters rather than runtime allocators.

**Error handling evolution**: Uses specific, typed error sets rather than generic error types:
- `OverflowError`, `InvalidModulusError`, `NullExponentError`, `FieldElementError`, `RepresentationError`
- Combined into `Error` union for function signatures

**API structure patterns**:
- **Factory functions**: `fromPrimitive()`, `fromBytes()` for type construction
- **Conversion methods**: `toPrimitive()`, `toBytes()` for output
- **Montgomery domain handling**: Explicit `toMontgomery()`/`fromMontgomery()` conversions
- **Public vs secret exponent differentiation**: Separate `powPublic()` vs `pow()` methods

**Side-channel protection**: Uses `std.options.side_channels_mitigations` to conditionally compile constant-time operations

## 3) The Golden Snippet

```zig
const std = @import("std");
const crypto = std.crypto;

// Create a 256-bit modulus from a primitive value
const M = crypto.ff.Modulus(256);
const modulus = try M.fromPrimitive(u256, 3429938563481314093726330772853735541133072814650493833233);

// Create field elements
const x = try M.Fe.fromPrimitive(u256, modulus, 80169837251094269539116136208111827396136208141182357733);
const y = try M.Fe.fromPrimitive(u256, modulus, 24620149608466364616251608466389896540098571);

// Perform modular multiplication
const product = modulus.mul(x, y);

// Convert to Montgomery form and back
var x_mont = x;
try modulus.toMontgomery(&x_mont);
// ... operations in Montgomery domain ...
try modulus.fromMontgomery(&x_mont);

// Modular exponentiation with public exponent
const result = try modulus.powPublic(x, y);
```

## 4) Dependencies

- `std.math` - Mathematical operations (shr, shl, divCeil, mulWide, etc.)
- `std.mem` - Memory operations (@memcpy, @memset)
- `std.meta` - Type introspection (Int type creation)
- `std.crypto` - Timing-safe comparisons and side-channel protection
- `std.debug` - Assertions
- `std.builtin` - Endianness and target information

**Note**: This is a self-contained cryptographic module with no external dependencies beyond core Zig standard library components.