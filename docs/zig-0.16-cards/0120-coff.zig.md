# Migration Card: `std/coff.zig`

## 1) Concept

This file provides comprehensive support for parsing and manipulating COFF (Common Object File Format) and PE (Portable Executable) file formats used primarily on Windows systems. It defines structures for all major components of COFF/PE files including headers, optional headers, section headers, symbol tables, import/export directories, and relocation information. The main `Coff` struct serves as a parser that can read both object files and loaded images, providing methods to access various parts of the file format.

Key components include:
- Structure definitions for all COFF/PE headers and data directories
- Symbol table and string table parsing capabilities
- Support for both 32-bit (PE32) and 64-bit (PE32+) formats
- Import/export directory parsing
- Relocation and debug information handling

## 2) The 0.11 vs 0.16 Diff

This file primarily contains structure definitions and parsing logic rather than public API functions with allocator dependencies. However, there are notable patterns:

**Explicit Allocator Requirements:**
- `getSectionHeadersAlloc(allocator: mem.Allocator)` - requires explicit allocator for copying section headers
- `getSectionDataAlloc(allocator: mem.Allocator)` - requires explicit allocator for duplicating section data

**I/O Interface Changes:**
- Uses `std.Io.Reader` pattern internally for reading structured data from the COFF file
- No traditional file I/O dependencies - operates on memory buffers

**Error Handling:**
- Defines custom error set `Error` with COFF-specific error cases
- Uses standard Zig error handling with explicit error sets

**API Structure:**
- Uses factory pattern with `Coff.init(data, is_loaded)` rather than direct struct initialization
- Allocator-based methods clearly marked with `Alloc` suffix

## 3) The Golden Snippet

```zig
const std = @import("std");
const coff = std.coff;

pub fn analyzeCoffFile(data: []const u8) !void {
    // Initialize COFF parser
    var coff_file = try coff.Coff.init(data, false);
    
    // Access header information
    const header = coff_file.getHeader();
    std.debug.print("Machine: {}\n", .{header.machine});
    std.debug.print("Sections: {}\n", .{header.number_of_sections});
    
    // Get section headers
    const sections = coff_file.getSectionHeaders();
    for (sections, 0..) |*sect, i| {
        const name = try coff_file.getSectionName(sect);
        std.debug.print("Section {}: {s}\n", .{i, name});
    }
    
    // Get PDB debug path if available
    if (try coff_file.getPdbPath()) |pdb_path| {
        std.debug.print("PDB: {s}\n", .{pdb_path});
    }
}
```

## 4) Dependencies

- `std.mem` - Used extensively for memory operations and buffer manipulation
- `std.debug` - Used for assertions and debugging
- `std.math` - Used for power-of-two calculations in alignment functions

The file is primarily self-contained for COFF format parsing and doesn't have heavy external dependencies beyond core memory and debugging utilities.