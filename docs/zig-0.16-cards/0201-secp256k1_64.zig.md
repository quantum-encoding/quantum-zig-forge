# Migration Card: secp256k1 Curve Arithmetic Implementation

## 1) Concept

This file is an auto-generated implementation of secp256k1 elliptic curve arithmetic operations using 64-bit word-by-word Montgomery multiplication. It provides low-level cryptographic primitives for the Bitcoin/secp256k1 curve, implementing field arithmetic in both Montgomery and non-Montgomery domains.

Key components include:
- **MontgomeryDomainFieldElement**: Field elements in Montgomery representation (4×u64)
- **NonMontgomeryDomainFieldElement**: Field elements in standard representation (4×u64)  
- Core arithmetic operations: multiplication, squaring, addition, subtraction, negation
- Domain conversion functions between Montgomery and standard representations
- Serialization/deserialization utilities for field elements
- Division step implementation for modular inversion

## 2) The 0.11 vs 0.16 Diff

### No Allocator Requirements
- **Pattern**: All functions operate on caller-allocated output buffers
- **No explicit allocator parameters** in any public API
- Memory management is entirely caller's responsibility

### I/O Interface Changes
- **Direct pointer-based output**: Functions take `*Type` parameters for results
- **No dependency injection**: Pure mathematical functions without I/O abstractions
- **Stack-based operation**: All temporary variables are stack-allocated

### Error Handling Pattern
- **No error returns**: All functions return `void`
- **Runtime safety**: Uses `@setRuntimeSafety(mode == .Debug)` for bounds checking
- **Precondition validation**: Input bounds documented but not dynamically verified

### API Structure
- **Functional style**: Standalone functions, not methods on types
- **Explicit domain types**: Clear separation between Montgomery and non-Montgomery domains
- **Output-first parameters**: Consistent `out1: *Type` pattern across all functions

## 3) The Golden Snippet

```zig
const std = @import("std");
const secp256k1 = @import("secp256k1_64.zig");

pub fn example() void {
    var mont_result: secp256k1.MontgomeryDomainFieldElement = undefined;
    var std_result: secp256k1.NonMontgomeryDomainFieldElement = undefined;
    
    // Create two field elements in Montgomery domain
    const a = secp256k1.MontgomeryDomainFieldElement{ 0x1000003d1, 0x0, 0x0, 0x0 };
    const b = secp256k1.MontgomeryDomainFieldElement{ 0x2000007a2, 0x0, 0x0, 0x0 };
    
    // Multiply in Montgomery domain
    secp256k1.mul(&mont_result, a, b);
    
    // Convert result back to standard domain
    secp256k1.fromMontgomery(&std_result, mont_result);
    
    // Check if result is non-zero
    var nonzero: u64 = undefined;
    secp256k1.nonzero(&nonzero, std_result);
}
```

## 4) Dependencies

- **std**: Standard library imports (minimal usage)
- **builtin.mode**: Runtime safety mode configuration
- **No external dependencies**: Self-contained cryptographic implementation
- **No memory allocators**: Pure computational functions
- **No network/file I/O**: Mathematical operations only

This file represents a stable, low-level cryptographic primitive with minimal migration impact between Zig versions, as it avoids higher-level abstractions that typically require migration changes.