# Migration Card: std/sort/pdq.zig

## 1) Concept
This file implements Pattern-Defeating Quicksort (PDQ), an unstable in-place sorting algorithm. It provides two main public APIs: `pdq` for type-safe sorting of slices with a comparison function, and `pdqContext` for lower-level index-based sorting with custom swap/compare operations. The algorithm offers O(n) best-case performance and O(n log n) worst-case performance while using only O(log n) stack memory without requiring an allocator.

Key components include the main sorting logic with fallbacks to insertion sort for small arrays and heapsort for worst-case scenarios, pivot selection using Tukey's ninther method, pattern breaking for handling partially sorted data, and various partitioning strategies.

## 2) The 0.11 vs 0.16 Diff

**No Allocator Required**: Both public functions operate without allocators, using only stack memory. This is consistent with Zig's philosophy of explicit memory management.

**Context-Based API Pattern**: The primary migration pattern here is the context-based interface:

- `pdq()` takes a type `T`, slice `[]T`, context, and comparison function
- `pdqContext()` works directly with indices and requires a context with `swap` and `lessThan` methods
- Both use generic context parameters (`anytype`) rather than specific interfaces

**Function Signature Changes**:
- No explicit allocator parameters (unlike many other stdlib APIs)
- Generic context system allows dependency injection of comparison/swapping logic
- Index-based operations rather than pointer-based

**Error Handling**: Both functions are `void` returning with no error handling - they perform in-place sorting and cannot fail.

## 3) The Golden Snippet

```zig
const std = @import("std");
const pdq = std.sort.pdq;

// Context and comparison function
const SortContext = struct {
    reverse: bool,
};

fn compareInts(ctx: SortContext, lhs: i32, rhs: i32) bool {
    return if (ctx.reverse) lhs > rhs else lhs < rhs;
}

// Usage
var numbers = [_]i32{5, 2, 8, 1, 9};
const context = SortContext{ .reverse = false };

pdq(i32, &numbers, context, compareInts);
// numbers is now [1, 2, 5, 8, 9]
```

## 4) Dependencies

- `std.mem` - for `swap` operations
- `std.math` - for `floorPowerOfTwo`, `ceilPowerOfTwoAssert`, `log2`, `maxInt`
- `std.sort` - for `insertionContext` and `heapContext` fallbacks
- `std.testing` - for test assertions and validation

The dependency graph shows this is a core sorting algorithm that builds on basic math and memory operations while providing fallbacks to other sorting algorithms.