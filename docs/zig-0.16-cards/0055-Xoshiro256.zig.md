# Migration Card: std.Random.Xoshiro256.zig

## 1) Concept
This file implements the Xoshiro256++ pseudorandom number generator algorithm. It provides a high-performance 64-bit PRNG with a 256-bit state space, suitable for statistical applications and simulations. The key components include:
- State management with four 64-bit integers (`s[4]`)
- Core generation via the `next()` function that produces 64-bit random values
- Buffer filling capability through `fill()` for byte-oriented random data
- Jump-ahead functionality via `jump()` for parallel sequence generation

The implementation follows a direct state manipulation pattern without heap allocation, making it suitable for performance-critical applications while maintaining the mathematical properties of the Xoshiro256++ algorithm.

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
No allocator dependencies found. The API uses stack-based initialization:
```zig
// No allocator needed - direct struct initialization
var r = Xoshiro256.init(seed_value);
```

### I/O Interface Changes
No I/O dependencies. The PRNG operates purely on internal state without external I/O interfaces.

### Error Handling Changes
No error handling in the API. All functions either return values directly or modify state in-place without error conditions.

### API Structure Changes
- **Direct struct initialization**: Uses `init(seed)` pattern returning the struct directly
- **Method-based API**: All operations are methods on `*Xoshiro256` instances
- **Random interface compatibility**: Provides `random()` method that returns `std.Random` interface

Key signature patterns:
```zig
pub fn init(init_s: u64) Xoshiro256  // Factory function
pub fn random(self: *Xoshiro256) std.Random  // Interface adapter
pub fn next(self: *Xoshiro256) u64  // Stateful operation
```

## 3) The Golden Snippet

```zig
const std = @import("std");
const Xoshiro256 = std.Random.Xoshiro256;

// Initialize with seed
var prng = Xoshiro256.init(0x123456789ABCDEF);

// Generate individual random values
const random_u64 = prng.next();

// Use through std.Random interface  
var random = prng.random();
const random_int = random.int(u32);
const random_float = random.float(f64);

// Fill byte buffers
var buffer: [100]u8 = undefined;
prng.fill(&buffer);

// Jump ahead in sequence (for parallel streams)
prng.jump();
```

## 4) Dependencies

- `std` - Core standard library
- `std.math` - For bit rotation operations (`rotl`)
- `std.Random` - For Random interface and SplitMix64 seeding
- `std.mem` - Used in tests only (for buffer comparisons)

**Note**: This is a self-contained PRNG implementation with minimal dependencies, primarily relying on mathematical operations and the core Random interface.