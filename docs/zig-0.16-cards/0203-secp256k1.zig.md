# Migration Card: `std/crypto/pcurves/secp256k1.zig`

## 1) Concept

This file implements elliptic curve operations for secp256k1, the curve used in Bitcoin and other cryptocurrencies. It provides a complete implementation of point operations including addition, doubling, scalar multiplication, and serialization in SEC1 formats. The key components include the `Secp256k1` struct representing elliptic curve points in projective coordinates, `AffineCoordinates` for affine coordinate representation, and optimized multiplication algorithms using precomputation and endomorphism techniques for performance.

The implementation includes constant-time operations for security-critical paths and variable-time operations for public data where timing attacks aren't a concern. It supports both compressed and uncompressed point serialization formats, coordinate recovery from X coordinates, and specialized algorithms for the base point multiplication.

## 2) The 0.11 vs 0.16 Diff

**No significant API signature changes detected** - this is a mathematical cryptography implementation that follows consistent patterns:

- **No allocator requirements**: All operations work with fixed-size arrays and stack-allocated structures
- **Consistent error handling**: Uses specific error types from `crypto.errors` (`EncodingError`, `IdentityElementError`, etc.)
- **Stable I/O patterns**: Serialization uses fixed-size arrays rather than dynamic allocation
- **Mathematical focus**: API centers around mathematical operations rather than resource management

Key public APIs remain stable:
- `fromAffineCoordinates()`, `fromSerializedAffineCoordinates()` - point construction
- `fromSec1()`, `toCompressedSec1()`, `toUncompressedSec1()` - serialization
- `mul()`, `mulPublic()` - scalar multiplication
- `add()`, `sub()`, `dbl()` - point arithmetic

## 3) The Golden Snippet

```zig
const std = @import("std");
const secp256k1 = std.crypto.pcurves.secp256k1;

// Create a random point on the curve
const random_point = secp256k1.Secp256k1.random();

// Serialize to compressed SEC1 format
const compressed = random_point.toCompressedSec1();

// Deserialize back from SEC1 format
const deserialized = try secp256k1.Secp256k1.fromSec1(&compressed);

// Verify the points are equivalent
const is_same = random_point.equivalent(deserialized);
```

## 4) Dependencies

- `std.mem` - for memory operations and endian handling
- `std.math` - for mathematical operations
- `std.crypto.errors` - for cryptographic error types
- `std.meta` - for compile-time introspection
- Internal dependencies: `secp256k1/field.zig`, `secp256k1/scalar.zig`

This implementation has minimal external dependencies and focuses purely on mathematical operations, making it stable across Zig versions.