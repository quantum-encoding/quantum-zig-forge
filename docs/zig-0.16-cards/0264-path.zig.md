# Migration Card: `std.fs.path`

## 1) Concept

This file provides cross-platform path manipulation utilities for Zig's standard library. It handles path operations across different operating systems (Windows, POSIX, UEFI) with proper encoding support - using WTF-8 for Windows compatibility and UTF-8 for POSIX systems. The module focuses on path joining, resolution, decomposition (dirname/basename), relative path calculation, and path component iteration.

Key components include:
- Path joining functions (`join`, `joinZ`) that intelligently handle separators
- Path resolution functions (`resolve`, `resolveWindows`, `resolvePosix`) that handle `.` and `..` components
- Path analysis functions (`isAbsolute`, `dirname`, `basename`, `extension`, `stem`)
- Cross-platform path component iterator with bidirectional traversal
- Windows-specific path parsing and network share handling

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **All path manipulation functions now require explicit allocators**: `join()`, `joinZ()`, `resolve()`, `resolveWindows()`, `resolvePosix()`, `relative()`, `relativeWindows()`, `relativePosix()`
- Functions return allocated memory that must be freed by caller
- No implicit/default allocators - consistent with Zig's memory management philosophy

### API Structure Changes
- **Component-based path iteration**: New `ComponentIterator` type with bidirectional traversal
- **Platform-specific functions**: Clear separation with `Windows`/`Posix` suffixes (e.g., `resolveWindows` vs `resolvePosix`)
- **Enhanced path parsing**: `windowsParsePath()` returns structured `WindowsPath` instead of simple strings
- **Formatting support**: `fmtJoin()` for formatting paths without allocation

### Error Handling
- **ComponentIterator.init()** returns `InitError` on Windows for malformed paths (namespace prefixes, invalid UNC)
- Most functions use `Allocator.Error` for allocation failures
- Consistent error handling patterns across all allocation-based operations

## 3) The Golden Snippet

```zig
const std = @import("std");
const path = std.fs.path;

pub fn main() !void {
    var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena.deinit();
    const allocator = arena.allocator();

    // Join multiple path components
    const joined_path = try path.join(allocator, &[_][]const u8{ "src", "main", "file.zig" });
    std.debug.print("Joined path: {s}\n", .{joined_path});

    // Resolve path with .. and . components
    const resolved = try path.resolve(allocator, &[_][]const u8{ "src/../main/./file.zig" });
    std.debug.print("Resolved path: {s}\n", .{resolved});

    // Get relative path between two locations
    const relative_path = try path.relative(allocator, "/home/user/src", "/home/user/build/output");
    std.debug.print("Relative path: {s}\n", .{relative_path});

    // Iterate through path components
    var iter = try path.componentIterator("/usr/local/bin");
    while (iter.next()) |component| {
        std.debug.print("Component: {s} (full path: {s})\n", .{ component.name, component.path });
    }
}
```

## 4) Dependencies

- `std.mem` - Memory manipulation and tokenization
- `std.debug` - Assertions and debugging
- `std.testing` - Test utilities
- `std.ascii` - Character case handling
- `std.os.windows` - Windows-specific path handling
- `std.process` - Current working directory access
- `std.unicode` - UTF encoding conversions
- `std.fmt` - Path formatting
- `std.heap` - Memory allocation patterns

The file demonstrates Zig 0.16's emphasis on explicit memory management and cross-platform path handling with proper encoding support.