# LZMA2 Decompression Migration Analysis

## 1) Concept

This file implements an LZMA2 decompressor for the Zig standard library. LZMA2 is a container format for LZMA-compressed data that supports multiple compression modes and dictionary resets. The main components are:

- `AccumBuffer`: An accumulating buffer that manages LZ sequences during decompression, handling literal appends and LZ77-style backreferences
- `Decode`: The main LZMA2 decoder that orchestrates the decompression process, handling different packet types (uncompressed data, LZMA data with various reset modes)

The implementation provides streaming decompression capabilities with configurable memory limits and supports the full LZMA2 specification including state resets and property changes mid-stream.

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **Factory pattern with allocator**: `Decode.init(gpa: Allocator)` requires explicit allocator
- **Method-based allocator passing**: All `AccumBuffer` methods that allocate (`appendByte`, `appendLiteral`, `appendLz`, `deinit`) take allocator as parameter
- **No default allocator**: No global/default allocator assumption - all allocation is explicit

### I/O Interface Changes
- **Dependency injection**: Uses `std.Io.Reader` and `std.Io.Writer` interfaces throughout
- **Allocating writer pattern**: `decompress` method takes `*Writer.Allocating` which combines writer with allocator
- **Stream-oriented**: Designed for streaming input/output rather than one-shot operations

### Error Handling
- **Specific error types**: Uses domain-specific errors like `error.CorruptInput`, `error.DecompressedSizeMismatch`, `error.CompressedSizeMismatch`
- **No generic error sets**: Error handling is specific to decompression failures

### API Structure Changes
- **init/deinit pattern**: Clear resource management with `init`/`deinit` pairs
- **Stateful decoding**: `Decode` maintains state across multiple decompression calls
- **Accumulating buffer**: Separate `AccumBuffer` type for managing decompression state

## 3) The Golden Snippet

```zig
const std = @import("std");
const lzma2 = std.compress.lzma2;

pub fn main() !void {
    const gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Initialize decoder
    var decode = try lzma2.Decode.init(allocator);
    defer decode.deinit(allocator);

    // Compressed data
    const compressed = &[_]u8{0x01, 0x00, 0x05, 0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x0A, 0x00};
    
    // Create reader and writer
    var stream = std.io.fixedBufferStream(compressed);
    var result = std.io.Writer.Allocating.init(allocator);
    defer result.deinit();

    // Decompress
    const n_read = try decode.decompress(&stream.reader(), &result);
    
    std.debug.print("Read {} bytes, decompressed: {s}\n", .{n_read, result.written()});
}
```

## 4) Dependencies

- `std.mem` (as `Allocator`)
- `std.ArrayList` (for dynamic buffer management)
- `std.compress.lzma` (underlying LZMA decoder)
- `std.io.Reader`/`std.io.Writer` (I/O interfaces)
- `std.math` (for `maxInt` constant)

This file has moderate dependencies, primarily relying on core memory management and I/O components while integrating with the existing LZMA compression infrastructure.