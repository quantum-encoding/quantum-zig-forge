# Migration Card: P384 Elliptic Curve Implementation

## 1) Concept

This file implements group operations for the P384 elliptic curve (also known as secp384r1), which is a NIST-standardized elliptic curve used in cryptographic protocols. The implementation provides:

- Point arithmetic operations (addition, doubling, multiplication)
- Coordinate conversions between projective and affine representations
- SEC-1 format serialization/deserialization for elliptic curve points
- Constant-time and variable-time scalar multiplication algorithms
- Support for double-base multiplication used in signature verification

The core `P384` struct represents points in projective coordinates (x, y, z), while `AffineCoordinates` provides the affine representation. The implementation includes optimized algorithms for point operations and precomputation tables for performance.

## 2) The 0.11 vs 0.16 Diff

**No significant API signature changes detected.** This elliptic curve implementation follows consistent patterns:

- **No explicit allocator requirements**: All operations are stack-based without dynamic allocation
- **No I/O interface changes**: Serialization uses fixed-size arrays, not stream interfaces
- **Error handling consistency**: Uses specific crypto error types (`EncodingError`, `IdentityElementError`, etc.) consistently
- **API structure stability**: Factory functions like `fromAffineCoordinates()` and `fromSec1()` maintain consistent signatures

The public API maintains mathematical purity - operations take and return fixed-size values without side effects. The scalar multiplication functions accept endianness parameters but this was likely present in 0.11 as well.

## 3) The Golden Snippet

```zig
const std = @import("std");
const p384 = std.crypto.pcurves.P384;

// Create a point from SEC1-encoded compressed format
const sec1_data = [49]u8{0x03} ++ [_]u8{0x00} ** 48; // Example compressed point
const point = try p384.fromSec1(&sec1_data);

// Multiply by a scalar (constant-time)
const scalar = [_]u8{0x01} ** 48;
const result = try point.mul(scalar, .big);

// Convert to uncompressed SEC1 format
const uncompressed = result.toUncompressedSec1();
```

## 4) Dependencies

- `std.mem` - Memory operations and utilities
- `std.crypto` - Core cryptographic functionality and error types
- `std.meta` - Type metadata and compile-time introspection
- `std.builtin.Endian` - Endianness specification for serialization

**Module Import Graph:**
- `p384/field.zig` - Prime field arithmetic implementation
- `p384/scalar.zig` - Scalar field arithmetic modulo curve order

This implementation has minimal external dependencies and is primarily self-contained within the crypto module, with field and scalar operations delegated to specialized submodules.