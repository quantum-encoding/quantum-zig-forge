# Migration Card: std/math/powi.zig

## 1) Concept

This file implements integer power functions (`powi`) for Zig's standard library math module. It provides a generic function that calculates `x^y` (x raised to the power of y) for integer types, with comprehensive overflow and underflow detection. The implementation handles edge cases including zero exponents, negative bases with even/odd exponents, and boundary conditions where results would exceed the type's representable range.

Key components include:
- A single public `powi` function that takes a comptime type parameter and two integer values
- Error handling for overflow and underflow conditions
- Special case handling for common patterns (0^y, x^0, (-1)^y, etc.)
- Efficient exponentiation using repeated squaring algorithm

## 2) The 0.11 vs 0.16 Diff

**No significant API signature changes detected** for this mathematical utility function:

- **No allocator requirements**: This is a pure mathematical function that operates on integers without memory allocation
- **No I/O interface changes**: Function doesn't involve I/O operations
- **Error handling consistency**: Uses a specific error set `{Overflow, Underflow}` which aligns with Zig's error handling principles
- **API structure**: Simple functional API without init/open patterns

The function signature remains consistent with mathematical utility patterns:
```zig
pub fn powi(comptime T: type, x: T, y: T) (error{Overflow, Underflow}!T)
```

## 3) The Golden Snippet

```zig
const std = @import("std");
const math = std.math;

// Calculate 5^3 for i32
const result = try math.powi(i32, 5, 3);
// result = 125

// Handle potential overflow/underflow
const maybe_result = math.powi(u8, 2, 8);
// maybe_result is error.Overflow!u8
```

## 4) Dependencies

- `std.math` - Mathematical constants and utilities
- `std.debug` - Assertion functionality for debugging
- `std.testing` - Testing framework (test-only dependency)

This file has minimal external dependencies, focusing purely on mathematical operations without requiring memory allocation or system interfaces.