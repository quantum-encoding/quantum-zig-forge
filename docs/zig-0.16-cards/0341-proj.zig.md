```markdown
# Migration Card: std/math/complex/proj.zig

## 1) Concept
This file implements complex number projection onto the Riemann sphere. The `proj` function takes a complex number and returns its projection, which handles infinite values specially by mapping them to complex infinity while preserving the sign of the real component. For finite inputs, it returns the input unchanged.

Key components:
- Single public function `proj` that performs Riemann sphere projection
- Handles special cases for infinite real/imaginary parts
- Returns a new `Complex` instance with the projected values

## 2) The 0.11 vs 0.16 Diff

**Complex Type Construction Pattern:**
- **0.16 Pattern**: Uses `Complex(T).init(re, im)` constructor syntax
- **0.11 Alternative**: Previous versions might have used different construction patterns like tuple returns or direct struct initialization

**Type System Changes:**
- Uses `@TypeOf(z.re, z.im)` for type deduction from complex number components
- Leverages `math.inf(T)` and `math.copysign()` for type-safe infinity and sign operations

**API Structure:**
- Maintains functional style with pure mathematical operations
- No allocator requirements (value types only)
- No I/O interface dependencies
- No error handling (deterministic mathematical operations)

## 3) The Golden Snippet

```zig
const std = @import("std");
const math = std.math;
const Complex = math.complex.Complex;

// Create a complex number and project it
const input = Complex(f32).init(5, 3);
const result = math.complex.proj(input);

// Result will be Complex(f32).init(5, 3)
std.debug.print("Projection: {d} + {d}i\n", .{result.re, result.im});
```

## 4) Dependencies
- `std.math` - Mathematical constants and functions (isInf, inf, copysign)
- `std.math.complex` - Complex number type and operations
- `std.testing` - Test framework (test-only dependency)

**No heavy dependencies** - This is a pure mathematical utility with minimal stdlib dependencies.
```