# Migration Card: std.Thread.Pool

## 1) Concept

This file implements a thread pool for Zig's standard library, providing a mechanism to execute concurrent tasks across multiple worker threads. The pool manages thread lifecycle, task queuing, and synchronization using mutexes and condition variables. Key components include a run queue for pending tasks, worker threads that process tasks, and optional thread ID tracking for identifying worker threads.

The pool supports both simple task spawning and more complex scenarios using wait groups for synchronization. It automatically handles single-threaded environments by executing tasks directly on the calling thread when appropriate, making it suitable for cross-platform development.

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **Factory pattern**: The pool is initialized via `init()` with an `Options` struct containing an explicit `allocator` field
- **Memory management**: All task closures are allocated using the pool's allocator and destroyed after execution
- **Resource cleanup**: `deinit()` properly cleans up all allocated resources including thread handles and ID tracking

### API Structure Changes
- **Lifecycle methods**: Uses `init()`/`deinit()` pattern rather than constructor/destructor functions
- **Flexible thread count**: `n_jobs` option defaults to CPU count but can be overridden
- **Wait group integration**: `spawnWg()` and `spawnWgId()` methods integrate with `WaitGroup` for synchronization

### Error Handling
- **Fallback execution**: When memory allocation fails for task queuing, functions execute directly on calling thread
- **Single-threaded fallback**: Automatically handles single-threaded targets by executing tasks synchronously

## 3) The Golden Snippet

```zig
const std = @import("std");
const Pool = std.Thread.Pool;
const WaitGroup = std.Thread.WaitGroup;

// Initialize pool
var pool: Pool = undefined;
try pool.init(.{
    .allocator = std.heap.page_allocator,
    .n_jobs = 4,  // Use 4 worker threads
});

defer pool.deinit();

// Use with wait group for synchronization
var wg = WaitGroup{};

// Spawn a task with wait group
pool.spawnWg(&wg, myTask, .{42, "hello"});

// Wait for completion
wg.wait();

fn myTask(value: i32, message: []const u8) void {
    std.debug.print("Task received: {} {s}\n", .{value, message});
}
```

## 4) Dependencies

- **std.mem** - For allocator interfaces and memory management
- **std.Thread** - For thread creation and synchronization primitives (Mutex, Condition)
- **std.SinglyLinkedList** - For the task run queue implementation
- **std.AutoArrayHashMapUnmanaged** - For optional thread ID tracking
- **builtin** - For target-specific configuration (single_threaded detection)

The pool has moderate dependencies on core threading and memory management modules, making it self-contained within the std.Thread namespace while relying on fundamental allocator and synchronization primitives.