# Migration Card: std/crypto/aes.zig

## 1) Concept

This file provides AES (Advanced Encryption Standard) cryptographic functionality for Zig's standard library. It serves as a unified interface that automatically selects the optimal implementation based on available hardware capabilities: AES-NI on x86_64, ARM Crypto Extensions on AArch64, or a software fallback implementation. The module exposes symmetric encryption contexts for both AES-128 and AES-256, allowing users to perform block encryption and decryption operations.

Key components include encryption/decryption contexts (`AesEncryptCtx`, `AesDecryptCtx`), AES variants (`Aes128`, `Aes256`), and block data structures. The implementation is CPU-aware and provides hardware acceleration when available, with a public constant `has_hardware_support` to indicate whether the current platform supports hardware-accelerated AES operations.

## 2) The 0.11 vs 0.16 Diff

**No significant API changes detected from 0.11 patterns.** This module follows consistent patterns that have remained stable:

- **No explicit allocator requirements**: The API uses stack-allocated contexts and direct initialization without memory allocation dependencies
- **Stateless initialization**: Both `Aes128` and `Aes256` use simple `initEnc` and `initDec` factory methods that take only the encryption key
- **Direct method calls**: Encryption/decryption operations are performed via direct method calls on context objects without complex dependency injection
- **Fixed error handling**: The API appears to use simple error-less operations for the core cryptographic functions

The initialization pattern (`Aes128.initEnc(key)`, `Aes256.initDec(key)`) and usage pattern (`ctx.encrypt(out, in)`, `ctx.decrypt(out, in)`) remain consistent with Zig's established cryptographic APIs.

## 3) The Golden Snippet

```zig
const std = @import("std");
const aes = std.crypto.aes;

// AES-128 encryption example
const key = [_]u8{ 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };
const plaintext = [_]u8{ 0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34 };

var ciphertext: [16]u8 = undefined;
var ctx = aes.Aes128.initEnc(key);
ctx.encrypt(&ciphertext, &plaintext);

// AES-128 decryption example  
var decrypted: [16]u8 = undefined;
var decrypt_ctx = aes.Aes128.initDec(key);
decrypt_ctx.decrypt(&decrypted, &ciphertext);
```

## 4) Dependencies

- `std` (root import)
- `builtin` (for CPU feature detection)
- `std.testing` (test framework only)

**Note**: The actual cryptographic implementations are conditionally imported from:
- `std/crypto/aes/aesni.zig` (x86_64 AES-NI)
- `std/crypto/aes/armcrypto.zig` (AArch64 crypto extensions)  
- `std/crypto/aes/soft.zig` (software fallback)

The public API is hardware-agnostic and automatically selects the optimal implementation.