# Migration Card: std.mem.zig

## 1) Concept

This file is the core memory manipulation module in Zig's standard library. It provides fundamental utilities for working with memory, including allocation wrappers, memory comparison, copying, searching, sorting, and byte manipulation. Key components include:

- **Allocator Validation**: `ValidationAllocator` wrapper that adds safety checks to any allocator
- **Memory Operations**: Functions for copying, comparing, and manipulating memory regions
- **String/Slice Utilities**: Tokenization, splitting, searching, and trimming operations
- **Endianness Handling**: Reading/writing integers with explicit endianness
- **Sorting Algorithms**: Both stable and unstable sorting implementations
- **Type Utilities**: Zero-initialization and type-safe memory operations

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **New Allocator Interface**: The `ValidationAllocator` uses the new vtable-based allocator pattern with `anyopaque` context pointers
- **Raw Allocator Methods**: Uses `rawAlloc`, `rawResize`, `rawRemap`, `rawFree` instead of direct function calls
- **Factory Pattern**: `validationWrap()` function creates validated allocator instances

### I/O Interface Changes
- **No Direct I/O**: This module focuses on memory operations rather than I/O
- **Byte Manipulation**: Enhanced byte swapping and endian conversion utilities

### Error Handling Changes
- **Allocator Errors**: Uses nullable returns (`?[*]u8`) instead of error unions for allocation failures
- **Validation Asserts**: Adds runtime assertions for allocator contract violations

### API Structure Changes
- **Zero Initialization**: New `zeroes()` and `zeroInit()` functions replace manual memset patterns
- **Enhanced Searching**: New `find*` family of functions (e.g., `findScalar`, `findAny`) replacing `indexOf*` naming
- **Sorting Context**: `sort()` and `sortUnstable()` use explicit context parameters for comparison functions

## 3) The Golden Snippet

```zig
const std = @import("std");
const mem = std.mem;

// Using ValidationAllocator with explicit allocator pattern
var arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);
defer arena.deinit();

const allocator = arena.allocator();
const validated_allocator = mem.validationWrap(allocator);

// Memory allocation with validation
const slice = try validated_allocator.allocator().alloc(u8, 100);
defer validated_allocator.allocator().free(slice);

// Memory operations
mem.set(u8, slice, 0xAA);
const found = mem.find(u8, slice, "pattern");

// String splitting with new iterator pattern
var split_iter = mem.splitSequence(u8, "key=value=another", "=");
while (split_iter.next()) |part| {
    std.debug.print("Part: {s}\n", .{part});
}
```

## 4) Dependencies

- **std.mem** (self)
- **std.math** - Mathematical operations and comparisons
- **std.debug** - Assertions and debugging utilities
- **std.builtin** - Compiler intrinsics and endian information
- **std.testing** - Test utilities and allocators
- **std.sort** - Sorting algorithm implementations
- **std.simd** - Vector operations for optimized comparisons
- **std.heap** - Allocator implementations (indirectly through tests)