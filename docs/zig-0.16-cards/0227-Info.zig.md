# Migration Card: std.debug.Info

## 1) Concept

This file provides a cross-platform abstraction for loading and querying debug information from binary files. The main `Info` structure serves as a container for loaded debug information that can map virtual memory addresses to source code locations. Key components include an address map storing loaded ELF files with their debug information and a reference to an externally managed `Coverage` instance for performing the actual address resolution.

The primary use case is for debugging tools and coverage analysis that need to translate program counter addresses back to source file locations, line numbers, and function names. Unlike `std.debug.SelfInfo`, this API is designed to work with debug information from arbitrary target architectures and operating systems, not just the host platform.

## 2) The 0.11 vs 0.16 Diff

**Explicit Allocator Requirements:**
- `load(gpa: Allocator, path: Path, coverage: *Coverage) LoadError!Info` - requires explicit allocator
- `deinit(info: *Info, gpa: Allocator) void` - requires explicit allocator for cleanup
- `resolveAddresses(info: *Info, gpa: Allocator, sorted_pc_addrs: []const u64, output: []SourceLocation) ResolveAddressesError!void` - requires explicit allocator

**API Structure Changes:**
- Factory pattern: `load()` returns initialized `Info` instance rather than requiring manual initialization
- Explicit resource management: `deinit()` must be called to clean up resources
- Error type consolidation: `LoadError` is a union of multiple specific error types
- External dependency injection: `Coverage` instance is passed in and externally managed

**Error Handling:**
- Specific error union: `LoadError = std.fs.File.OpenError || ElfFile.LoadError || std.debug.Dwarf.ScanError || error{MissingDebugInfo}`
- Separate error type for resolution: `ResolveAddressesError = Coverage.ResolveAddressesDwarfError`

## 3) The Golden Snippet

```zig
const std = @import("std");
const Info = std.debug.Info;
const Path = std.Build.Cache.Path;

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    const allocator = gpa.allocator();
    
    // Create a mock coverage instance (simplified - real usage would use actual coverage)
    var coverage = std.debug.Coverage{};
    
    // Load debug info from file
    const path = Path{
        .root_dir = std.fs.cwd(),
        .sub_path = "my_program",
    };
    var info = try Info.load(allocator, path, &coverage);
    defer info.deinit(allocator);
    
    // Resolve addresses to source locations
    const addresses = [_]u64{ 0x400510, 0x400520 };
    var locations: [addresses.len]std.debug.Coverage.SourceLocation = undefined;
    try info.resolveAddresses(allocator, &addresses, &locations);
}
```

## 4) Dependencies

- `std.mem` (for `Allocator`)
- `std.Build.Cache` (for `Path`)
- `std.debug.ElfFile` (ELF file parsing)
- `std.debug.Coverage` (coverage analysis and address resolution)
- `std.fs.File` (file I/O operations)
- `std.debug.Dwarf` (DWARF debug info parsing)