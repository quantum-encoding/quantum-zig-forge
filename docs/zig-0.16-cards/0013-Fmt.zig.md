# Migration Card: `std/Build/Step/Fmt.zig`

## 1) Concept

This file implements a build system step for running Zig's code formatter (`zig fmt`) as part of the build process. It provides two operational modes: **modify mode** (directly formats source files in place) and **check mode** (fails the build if any files don't conform to formatting standards).

Key components include:
- `Fmt` step structure containing configuration for paths, exclusions, and mode
- `Options` struct for configuring the formatter behavior
- A factory function `create()` that instantiates the step with proper initialization
- A `make()` function that executes the formatter and handles output processing

## 2) The 0.11 vs 0.16 Diff

**Factory Pattern with Explicit Build Context:**
- **0.16 Pattern:** `pub fn create(owner: *std.Build, options: Options) *Fmt`
- **Migration:** Steps are now created through factory functions that require explicit build context (`*std.Build`) rather than direct struct initialization

**Memory Management:**
- Uses `owner.allocator` and `owner.dupeStrings()` for memory duplication
- Build system manages all allocations through its allocator rather than requiring external allocator parameters

**Child Process Execution:**
- Uses `step.captureChildProcess()` with explicit progress node and allocator
- Error handling through `step.handleChildProcessTerm()` and `step.addError()`

**Configuration Injection:**
- Options struct passed directly to factory function
- Path resolution through `b.pathFromRoot()` for proper build root handling

## 3) The Golden Snippet

```zig
const std = @import("std");

pub fn build(b: *std.Build) void {
    const fmt_step = std.Build.Step.Fmt.create(b, .{
        .paths = &.{"src", "lib"},
        .exclude_paths = &.{"src/legacy"},
        .check = true, // Set to false for modify mode
    });
    
    // Add to build dependencies
    b.getInstallStep().dependOn(fmt_step);
}
```

## 4) Dependencies

- `std` - Core standard library
- `std.Build.Step` - Build step infrastructure
- `std.mem` - String tokenization for output parsing
- (Implicit) `std.ArrayListUnmanaged` - Command argument building
- (Implicit) `std.ChildProcess` - Subprocess execution via `captureChildProcess`