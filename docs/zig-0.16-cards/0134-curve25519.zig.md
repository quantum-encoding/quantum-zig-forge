# Migration Card: std/crypto/25519/curve25519.zig

## 1) Concept

This file implements group operations over Curve25519, which is the elliptic curve used in X25519 key exchange. It provides the core mathematical operations for working with Curve25519 points, including point encoding/decoding, scalar multiplication, and cofactor clearing. The key components include point representation (`Curve25519` struct), field arithmetic operations, and the Montgomery ladder implementation for scalar multiplication.

The module handles security-critical operations like rejecting non-canonical point encodings, checking for identity elements, and preventing small-subgroup attacks through cofactor clearing. It also provides conversion from Edwards25519 format (used in Ed25519 signatures) to Curve25519 format.

## 2) The 0.11 vs 0.16 Diff

**No significant migration changes detected** - this module follows consistent Zig patterns:

- **No allocator requirements**: All operations work with fixed-size arrays and stack-allocated types
- **No I/O interface changes**: Pure mathematical operations without I/O dependencies
- **Error handling**: Uses specific error types (`IdentityElementError`, `NonCanonicalError`, `WeakPublicKeyError`) rather than generic errors
- **API structure**: Consistent constructor pattern with `fromBytes()` and static `basePoint`

The public API maintains the same structure:
- `fromBytes(s: [32]u8) Curve25519` - Pure constructor
- `toBytes(p: Curve25519) [32]u8` - Pure method
- `rejectNonCanonical(s: [32]u8) NonCanonicalError!void` - Validation function
- Mathematical operations return specific error unions

## 3) The Golden Snippet

```zig
const std = @import("std");
const Curve25519 = std.crypto.25519.Curve25519;

test "curve25519_basic_operations" {
    // Create a scalar for multiplication
    var scalar = [32]u8{ 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8, 1, 2, 3, 4, 5, 6, 7, 8 };
    
    // Multiply base point by scalar (with clamping for DH)
    const point = try Curve25519.basePoint.clampedMul(scalar);
    
    // Verify the point is valid (not identity)
    try point.rejectIdentity();
    
    // Convert to compressed form
    const encoded = point.toBytes();
    
    // Decode back to point
    const decoded = Curve25519.fromBytes(encoded);
    
    // Verify encoding is canonical
    try Curve25519.rejectNonCanonical(encoded);
}
```

## 4) Dependencies

- `std.crypto` - Core cryptographic primitives
- `std.crypto.errors` - Error types (`IdentityElementError`, `NonCanonicalError`, `WeakPublicKeyError`)
- `std.crypto.ecc.Edwards25519` - For conversion from Edwards format
- `std.testing` - Test utilities (development only)

**Note**: This module has internal dependencies on:
- `field.zig` (for `Fe` field arithmetic)
- `scalar.zig` (for scalar operations)