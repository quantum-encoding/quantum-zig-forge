# Migration Card: `std/crypto/chacha20.zig`

## 1) Concept

This file implements the ChaCha20 stream cipher and its variants, including authenticated encryption with Poly1305. It provides multiple configurations of the ChaCha algorithm with different round counts (8, 12, 20) and nonce sizes (64-bit, 96-bit, 192-bit for XChaCha). The implementation includes both vectorized and scalar implementations that are automatically selected based on CPU capabilities.

Key components include:
- Stream cipher variants: `ChaCha20IETF`, `ChaCha12IETF`, `ChaCha8IETF`, `ChaCha20With64BitNonce`, etc.
- Authenticated encryption: `ChaCha20Poly1305`, `XChaCha20Poly1305` and their reduced-round variants
- XChaCha extended nonce variants for better security properties
- Both vectorized (AVX2, AVX512, NEON) and scalar implementations

## 2) The 0.11 vs 0.16 Diff

This crypto module shows minimal migration impact from Zig 0.11 to 0.16 patterns:

**No Explicit Allocator Requirements**: All operations are pure computations on provided buffers - no heap allocation required.

**No I/O Interface Changes**: The API operates directly on slices and arrays without dependency injection patterns.

**Error Handling Consistency**: Uses specific error types (`AuthenticationError`) consistently, no generic error union changes.

**API Structure Stability**: The function signatures remain consistent:
- `xor(out: []u8, in: []const u8, counter: u32/u64, key: [key_length]u8, nonce: [nonce_length]u8)`
- `stream(out: []u8, counter: u32/u64, key: [key_length]u8, nonce: [nonce_length]u8)`
- `encrypt(c: []u8, tag: *[tag_length]u8, m: []const u8, ad: []const u8, npub: [nonce_length]u8, k: [key_length]u8)`
- `decrypt(m: []u8, c: []const u8, tag: [tag_length]u8, ad: []const u8, npub: [nonce_length]u8, k: [key_length]u8) AuthenticationError!void`

The public API maintains the same structure and calling patterns from Zig 0.11.

## 3) The Golden Snippet

```zig
const std = @import("std");
const crypto = std.crypto;

// Example: Authenticated encryption with ChaCha20-Poly1305
fn example_aead() !void {
    const message = "Hello, ChaCha20-Poly1305!";
    const ad = "associated-data";
    const key = [_]u8{0x01} ** crypto.chacha20.ChaCha20Poly1305.key_length;
    const nonce = [_]u8{0x02} ** crypto.chacha20.ChaCha20Poly1305.nonce_length;
    
    var ciphertext: [message.len]u8 = undefined;
    var tag: [crypto.chacha20.ChaCha20Poly1305.tag_length]u8 = undefined;
    
    // Encrypt
    crypto.chacha20.ChaCha20Poly1305.encrypt(
        &ciphertext, 
        &tag, 
        message, 
        ad, 
        nonce, 
        key
    );
    
    // Decrypt
    var decrypted: [message.len]u8 = undefined;
    try crypto.chacha20.ChaCha20Poly1305.decrypt(
        &decrypted, 
        &ciphertext, 
        tag, 
        ad, 
        nonce, 
        key
    );
    
    // Verify decryption matches original
    std.debug.assert(std.mem.eql(u8, &decrypted, message));
}
```

## 4) Dependencies

- `std.mem` - For memory operations, byte order conversions, and comparisons
- `std.math` - For bit rotation operations and integer utilities
- `std.crypto.onetimeauth.Poly1305` - For authentication in AEAD modes
- `std.crypto.errors.AuthenticationError` - For decryption failure cases
- `std.crypto.timing_safe` - For constant-time comparisons
- `std.debug.assert` - For runtime validation
- `std.testing` - For test framework (test-only)