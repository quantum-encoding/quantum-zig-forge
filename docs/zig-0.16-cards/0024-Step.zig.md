# Migration Card: std.Build.Step

## 1) Concept

This file defines the base `Step` struct that serves as the foundation for Zig's build system. A `Step` represents a unit of work in the build process, such as compiling code, running tests, or installing files. The file provides the core infrastructure for build step management, including dependency tracking, state management, error handling, and execution coordination.

Key components include:
- The main `Step` struct with fields for dependencies, state tracking, and results
- `TestResults` struct for tracking test execution outcomes  
- `MakeOptions` and `MakeFn` for step execution configuration
- Various step types like `Compile`, `Run`, `InstallFile` etc. that inherit from the base Step
- Input watching functionality for incremental builds

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **Allocator injection**: The `MakeOptions` struct now requires an explicit `gpa: Allocator` field, separating it from `Build.allocator`
- **Memory management**: Functions like `allocPrintCmd`, `allocPrintCmd2` explicitly take `gpa: Allocator` parameters
- **Resource cleanup**: Methods like `clearWatchInputs` and `reset` require explicit allocator parameters for cleanup

### I/O Interface Changes
- **Dependency injection**: `captureChildProcess` and `evalZigProcess` take explicit `progress_node: std.Progress.Node` parameters
- **File operations**: `installFile` and `installDir` use the new `Io.Dir` API with explicit directory handles
- **Process management**: Enhanced child process handling with `ZigProcess` struct using `Io.Poller`

### Error Handling Changes
- **Specific error sets**: `make` function returns specific error set `error{ MakeFailed, MakeSkipped }` instead of generic errors
- **Structured errors**: Uses `std.zig.ErrorBundle` for compilation error reporting instead of simple error messages
- **Error accumulation**: `result_error_msgs` and `result_error_bundle` provide structured error collection

### API Structure Changes
- **Factory pattern**: Steps are created via `Step.init()` with `StepOptions` rather than direct struct initialization
- **Input watching**: New `addWatchInput`, `clearWatchInputs`, and cache integration methods
- **Memory limits**: Added `max_rss` field for memory usage tracking and limits

## 3) The Golden Snippet

```zig
const std = @import("std");

// Create a custom build step
const MyCustomStep = struct {
    step: Step,
    custom_data: []const u8,

    pub const base_id = .custom;

    pub fn create(owner: *Build, name: []const u8, data: []const u8) *MyCustomStep {
        const self = owner.allocator.create(MyCustomStep) catch @panic("OOM");
        self.* = .{
            .step = Step.init(.{
                .id = .custom,
                .name = name,
                .owner = owner,
                .makeFn = make,
            }),
            .custom_data = owner.allocator.dupe(u8, data) catch @panic("OOM"),
        };
        return self;
    }

    fn make(step: *Step, options: Step.MakeOptions) anyerror!void {
        const self = @fieldParentPtr(MyCustomStep, "step", step);
        
        // Custom build logic here
        std.debug.print("Running custom step '{s}' with data: {s}\n", .{
            step.name, self.custom_data
        });
        
        // Depend on other steps
        for (step.dependencies.items) |dep| {
            try dep.make(options);
        }
        
        step.result_cached = false; // Force rebuild
    }
};

// Usage in build.zig
pub fn build(b: *std.Build) void {
    const custom_step = MyCustomStep.create(b, "my-step", "custom-data");
    
    // Add dependencies if needed
    // custom_step.step.dependOn(other_step);
    
    // Add to build graph
    b.getInstallStep().dependOn(&custom_step.step);
}
```

## 4) Dependencies

- **std.mem** - For `Allocator` type and memory management
- **std.Io** - For I/O operations, writers, and TTY configuration
- **std.process** - For child process execution and management
- **std.fs** - For file system operations and path handling
- **std.zig** - For error bundles and compiler server protocol
- **std.array_list** - For `ArrayList` and managed collections
- **std.time** - For timing and performance measurement
- **std.Progress** - For build progress reporting
- **std.Thread** - For thread pool integration
- **std.debug** - For assertions and stack traces