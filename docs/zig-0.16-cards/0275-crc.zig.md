# Migration Card: std/hash/crc.zig

## 1) Concept

This file is a comprehensive catalog of CRC (Cyclic Redundancy Check) algorithm implementations for Zig's standard library. It provides pre-configured CRC algorithms for various bit widths (3-bit through 82-bit) and standards. The file is auto-generated by `tools/update_crc_catalog.zig` and serves as a public API for developers to access standardized CRC implementations without manually configuring polynomial parameters.

Key components include:
- A generic `Crc` type constructor that takes a bit width and configuration parameters
- Pre-defined CRC algorithms for common standards (CRC32, CRC16, CRC8 variants, etc.)
- Mathematical parameters for each algorithm including polynomial, initial value, reflection settings, and final XOR

## 2) The 0.11 vs 0.16 Diff

This file primarily uses **comptime type construction patterns** rather than runtime function APIs. The key migration patterns observed:

**Type-Based API Construction**: Instead of runtime factory functions, CRCs are constructed as types at comptime:
```zig
// 0.16 pattern - type-based construction
pub const Crc32 = Crc(u32, .{
    .polynomial = 0x04c11db7,
    .initial = 0xffffffff,
    .reflect_input = true,
    .reflect_output = true,
    .xor_output = 0xffffffff,
});
```

**No Allocator Dependencies**: The CRC implementations are pure computational types with no memory allocation requirements.

**Comptime Configuration**: All parameters (polynomial, initial values, reflection settings) are provided as comptime struct literals rather than runtime function arguments.

## 3) The Golden Snippet

```zig
const std = @import("std");
const Crc32 = std.hash.crc.Crc32;

// Usage example computing CRC32 for data
pub fn main() void {
    const data = "Hello, World!";
    const hasher = Crc32.init();
    const checksum = hasher.hash(data);
    
    std.debug.print("CRC32 checksum: 0x{x}\n", .{checksum});
}
```

*Note: The actual hashing methods are defined in the underlying implementation (`crc/impl.zig`), but this shows the public API pattern for using the pre-configured CRC algorithms.*

## 4) Dependencies

- `std.hash.crc.impl` - Core CRC implementation
- (No heavy stdlib dependencies like std.mem or std.net - this is a pure computational module)

The module structure is self-contained within the hash/crc namespace, with the actual algorithm implementations residing in the `impl.zig` submodule.