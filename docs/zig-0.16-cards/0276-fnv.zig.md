# Migration Card: std/hash/fnv.zig

## 1) Concept

This file implements the FNV1a (Fowler-Noll-Vo) non-cryptographic hash function for 32-bit, 64-bit, and 128-bit variants. It provides a generic hash implementation that can process data incrementally through an update pattern or compute a hash in one shot. The key components are three public type aliases (`Fnv1a_32`, `Fnv1a_64`, `Fnv1a_128`) that instantiate the generic FNV1a implementation with specific parameters for each bit width.

The implementation follows a classic hashing pattern with initialization, incremental updates, and finalization. Each hash type maintains internal state that gets updated with input bytes and can produce a final hash value. The design supports both streaming hashing (for large data) and one-shot hashing (for convenience with small data).

## 2) The 0.11 vs 0.16 Diff

**No breaking API changes detected.** This hash implementation follows consistent patterns between Zig 0.11 and 0.16:

- **No allocator requirements**: All functions are allocation-free and work with stack-based state
- **No I/O interface changes**: Pure computational functions without file/stream dependencies
- **No error handling changes**: All operations are infallible (no error returns)
- **Consistent API structure**: Maintains the same `init/update/final` pattern and static `hash` function

The public API remains stable:
- `init()` - Creates initial hash state
- `update(self: *Self, input: []const u8)` - Incrementally processes data
- `final(self: *Self) T` - Returns computed hash value
- `hash(input: []const u8) T` - Convenience one-shot function

## 3) The Golden Snippet

```zig
const std = @import("std");
const Fnv1a_32 = std.hash.fnv.Fnv1a_32;

// One-shot hashing
const hash1 = Fnv1a_32.hash("hello world");

// Incremental hashing
var hasher = Fnv1a_32.init();
hasher.update("hello");
hasher.update(" ");
hasher.update("world");
const hash2 = hasher.final();
```

## 4) Dependencies

- `std.testing` - Used for test verification only
- Internal `verify.zig` - Test utilities (not part of public API)

**Note**: This is a self-contained hash implementation with minimal dependencies, making it highly portable and easy to migrate.