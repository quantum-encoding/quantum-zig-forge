# Migration Card: std/hash.zig

## 1) Concept
This file is a hash function aggregator module in Zig's standard library that provides access to various hashing algorithms. It serves as a centralized export point for multiple hash implementations including Adler32, CRC32, FNV, SipHash, Murmur, CityHash, Wyhash, and xxHash variants. The module also provides a generic `int` hashing function that can hash integers of any bit width up to 256 bits using specialized algorithms for common sizes (16, 32, 64 bits) and a general-purpose multiplier-based approach for other sizes.

## 2) The 0.11 vs 0.16 Diff
This module primarily consists of pure hash functions that don't require allocators or complex state management, so most migration patterns don't apply here. However, key observations:

- **No explicit allocator requirements**: All hash functions are stateless and don't require memory allocation
- **Pure functional interfaces**: Hash functions take input data and return hash values directly
- **Generic integer hashing**: The `int` function uses compile-time type reflection with `@typeInfo` and `@TypeOf` for type-safe integer hashing
- **Bit manipulation focus**: Heavy use of bit operations (`>>`, `^`, `*%`) and type conversion utilities

## 3) The Golden Snippet
```zig
const std = @import("std");

test "integer hashing example" {
    const input: u32 = 42;
    const hashed = std.hash.int(input);
    try std.testing.expectEqual(@as(u32, 0x42741D6), hashed);
}
```

## 4) Dependencies
- **std.testing** (test-only): Used for test assertions
- **No heavy runtime dependencies**: This is a pure computational module
- **Sub-module imports**: All actual implementations are in specialized sub-modules (hash/Adler32.zig, hash/crc.zig, hash/fnv.zig, etc.)

*Note: This module represents stable hashing APIs with minimal migration impact between 0.11 and 0.16.*