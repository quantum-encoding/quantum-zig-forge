# Migration Card: `std/math/cosh.zig`

## 1) Concept
This file implements hyperbolic cosine functions (`cosh`) for floating-point types in Zig's standard library. It provides type-generic `cosh` function that dispatches to type-specific implementations (`cosh32` for f32, `cosh64` for f64). The implementation is ported from musl libc and handles special cases including zeros, infinities, and NaNs according to IEEE 754 standards. The core algorithm uses different approximation methods based on the magnitude of the input value, switching between Taylor series expansions and exponential formulations for optimal accuracy.

## 2) The 0.11 vs 0.16 Diff
**No significant API changes detected for migration from 0.11 to 0.16.**

Analysis of the public API shows:
- `pub fn cosh(x: anytype) @TypeOf(x)` - Pure mathematical function with no allocator requirements
- No I/O interface dependencies
- No error handling changes (function doesn't return error unions)
- No structural API changes (no init/open patterns)
- Functions remain stateless mathematical operations

The implementation uses low-level floating-point bit manipulation and mathematical approximations that are stable across Zig versions. The public interface is a simple mathematical function that takes a numeric input and returns the hyperbolic cosine, making it immune to most breaking changes in Zig's standard library evolution.

## 3) The Golden Snippet
```zig
const std = @import("std");
const math = std.math;

pub fn main() void {
    const x: f64 = 1.5;
    const result = math.cosh(x);
    std.debug.print("cosh({}) = {}\n", .{x, result});
}
```

## 4) Dependencies
- `std.math` (mathematical constants and functions)
- `std.math.expo2` (exponential base-2 function)
- `std.testing` (test framework, development only)

**Note:** This is a pure mathematical function with minimal dependencies, primarily relying on other mathematical primitives in the same module. No allocator, networking, or complex I/O dependencies detected.