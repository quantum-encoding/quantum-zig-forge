# Migration Analysis: `std.fmt`

## 1) Concept

This file is Zig's main string formatting and parsing module, providing comprehensive utilities for converting between data types and string representations. It serves as the foundation for Zig's `std.fmt` functionality, including:

- Format string parsing with placeholder syntax (`{}`, `{d}`, `{x}`, etc.)
- Integer and floating-point formatting with various bases and precision
- String parsing into numeric types (`parseInt`, `parseUnsigned`)
- Buffer-based and allocator-based string formatting
- Hexadecimal encoding/decoding utilities
- Compile-time formatting support

Key components include the `Parser` for format string parsing, `Placeholder` for format specifiers, `Options` for formatting configuration, and various utility functions for number conversion and string manipulation.

## 2) The 0.11 vs 0.16 Diff

### Explicit Allocator Requirements
- **`allocPrint`**: Now requires explicit allocator parameter
  - 0.11: `allocPrint(fmt, args)` (implicit allocator)
  - 0.16: `allocPrint(gpa, fmt, args)` (explicit allocator)
- **`allocPrintSentinel`**: Same pattern with explicit allocator

### I/O Interface Changes
- **Writer dependency**: Uses `std.Io.Writer` instead of direct buffer writing
- **Error handling**: Format functions now return `Writer.Error` instead of direct error types
- **Buffer management**: Functions like `bufPrint` use `Writer.fixed()` pattern

### Error Handling Changes
- **`ParseIntError`**: Still uses specific error set (`Overflow`, `InvalidCharacter`)
- **`BufPrintError`**: New specific error type (`NoSpaceLeft`)
- **Function signatures**: Most parsing functions maintain consistent error sets

### API Structure Changes
- **Factory functions**: `bufPrint`, `allocPrint` maintain similar patterns but with updated internals
- **Sentinel handling**: `bufPrintSentinel` replaces deprecated `bufPrintZ`
- **Comptime support**: `comptimePrint` provides compile-time formatting

## 3) The Golden Snippet

```zig
const std = @import("std");

test "basic formatting example" {
    var buffer: [100]u8 = undefined;
    
    // Format into buffer
    const result = try std.fmt.bufPrint(&buffer, "Hello {s}, value: {d}", .{"World", 42});
    
    // Parse from string
    const number = try std.fmt.parseInt(i32, "12345", 10);
    
    // Allocator-based formatting
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();
    
    const allocated_string = try std.fmt.allocPrint(allocator, "Allocated: {}", .{number});
    defer allocator.free(allocated_string);
}
```

## 4) Dependencies

This module heavily imports:

- `std.mem` - Memory operations and allocator types
- `std.math` - Mathematical operations and constants
- `std.debug` - Assertions
- `std.meta` - Type introspection
- `std.testing` - Testing utilities
- `std.ascii` - Character classification
- `std.Io` - Writer interface (critical for formatting)

Submodules:
- `fmt/float.zig` - Floating-point formatting
- `fmt/parse_float.zig` - Floating-point parsing

The dependency graph shows this is a core utility module that depends on basic stdlib components but provides foundational formatting capabilities used throughout the ecosystem.