# Migration Card: `std/crypto/poly1305.zig`

## 1) Concept

This file implements the Poly1305 message authentication code (MAC) algorithm, which is a cryptographic primitive for authenticating messages. The implementation provides a stateful API for computing MACs incrementally (`init`, `update`, `final`) as well as a one-shot convenience function (`create`).

Key components include:
- The `Poly1305` struct that maintains the algorithm state (multiplier `r`, hash accumulator `h`, padding `end_pad`, and buffer for partial blocks)
- Core cryptographic operations for processing blocks and finalizing the MAC
- Both incremental processing for streaming data and one-shot computation for complete messages

## 2) The 0.11 vs 0.16 Diff

**No significant public API changes detected for migration from 0.11 to 0.16:**

- **No allocator requirements**: The API uses stack-allocated structs and doesn't require explicit memory allocators
- **No I/O interface changes**: The API operates directly on byte slices without reader/writer abstractions
- **No error handling changes**: All functions are `void`-returning and don't use error sets
- **Consistent API structure**: Uses standard `init` pattern for state initialization, not factory functions

The public API remains stable:
- `init(key)` → returns initialized struct (no allocator)
- `update(&self, data)` → processes data incrementally
- `final(&self, out)` → produces final MAC
- `create(out, msg, key)` → one-shot convenience function

## 3) The Golden Snippet

```zig
const std = @import("std");
const Poly1305 = std.crypto.Poly1305;

// One-shot MAC computation
pub fn example() void {
    const key: [32]u8 = [_]u8{0x85} ** 32; // 32-byte key
    const msg = "Cryptographic Forum Research Group";
    
    var mac: [16]u8 = undefined;
    Poly1305.create(&mac, msg, &key);
    
    // Use the computed MAC
    _ = mac;
}

// Incremental MAC computation
pub fn incremental_example() void {
    const key: [32]u8 = [_]u8{0x85} ** 32;
    const chunks = [_][]const u8{ "Hello, ", "world!", " This is a test." };
    
    var poly = Poly1305.init(&key);
    for (chunks) |chunk| {
        poly.update(chunk);
    }
    
    var mac: [16]u8 = undefined;
    poly.final(&mac);
}
```

## 4) Dependencies

- `std.mem` (for `readInt`, `writeInt`, byte manipulation)
- `std.math` (for `mulWide` - wide multiplication)
- `std.crypto.secureZero` (for secure memory zeroing in `final`)

The implementation is self-contained within the crypto module and doesn't import heavy external dependencies beyond core memory and math utilities.