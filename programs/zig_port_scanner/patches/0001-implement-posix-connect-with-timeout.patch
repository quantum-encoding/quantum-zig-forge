From: Community Contributor
Subject: [PATCH] Implement timeout support for POSIX network connections

This patch implements the TODO for timeout support in netConnectIpPosix,
enabling proper timeout behavior for TCP connections on POSIX systems.

The implementation uses non-blocking sockets with poll() to provide
accurate timeout handling while maintaining compatibility with Zig's
cancellation and error handling patterns.

Implementation details:
- Adds posixConnectWithTimeout() helper function
- Sets socket to non-blocking mode using fcntl when timeout is requested
- Uses poll() with millisecond-precision timeout
- Checks SO_ERROR socket option to determine connection success/failure
- Handles all edge cases: immediate connection, EINTR, timeout expiration

Tested on Linux x86_64 with various network scenarios including:
- Successful connections (localhost, remote servers)
- Connection refused (closed ports)
- Timeout scenarios (filtered ports, unreachable hosts)

Resolves: The panic "TODO implement netConnectIpPosix with timeout"
---
 lib/std/Io/Threaded.zig | 159 +++++++++++++++++++++++++++++++++++++---
 1 file changed, 150 insertions(+), 9 deletions(-)

diff --git a/lib/std/Io/Threaded.zig b/lib/std/Io/Threaded.zig
index 1234567..abcdefg 100644
--- a/lib/std/Io/Threaded.zig
+++ b/lib/std/Io/Threaded.zig
@@ -3339,6 +3339,119 @@ fn posixConnect(t: *Threaded, socket_fd: posix.socket_t, addr: *const posix.soc
     }
 }

+/// Connect with timeout using non-blocking socket + poll()
+/// Socket must be created with SOCK.NONBLOCK flag
+fn posixConnectWithTimeout(
+    t: *Threaded,
+    socket_fd: posix.socket_t,
+    addr: *const posix.sockaddr,
+    addr_len: posix.socklen_t,
+    timeout_ns: u64,
+) !void {
+    // Initiate non-blocking connect
+    while (true) {
+        try t.checkCancel();
+        switch (posix.errno(posix.system.connect(socket_fd, addr, addr_len))) {
+            .SUCCESS => return, // Connected immediately (localhost, etc.)
+            .INTR => continue,
+            .CANCELED => return error.Canceled,
+
+            // INPROGRESS is expected for non-blocking sockets - need to poll
+            .INPROGRESS, .AGAIN => break,
+
+            // All other errors are fatal
+            .ADDRNOTAVAIL => return error.AddressUnavailable,
+            .AFNOSUPPORT => return error.AddressFamilyUnsupported,
+            .ALREADY => return error.ConnectionPending,
+            .BADF => |err| return errnoBug(err),
+            .CONNREFUSED => return error.ConnectionRefused,
+            .CONNRESET => return error.ConnectionResetByPeer,
+            .FAULT => |err| return errnoBug(err),
+            .ISCONN => |err| return errnoBug(err),
+            .HOSTUNREACH => return error.HostUnreachable,
+            .NETUNREACH => return error.NetworkUnreachable,
+            .NOTSOCK => |err| return errnoBug(err),
+            .PROTOTYPE => |err| return errnoBug(err),
+            .TIMEDOUT => return error.Timeout,
+            .CONNABORTED => |err| return errnoBug(err),
+            .ACCES => return error.AccessDenied,
+            .PERM => |err| return errnoBug(err),
+            .NOENT => |err| return errnoBug(err),
+            .NETDOWN => return error.NetworkDown,
+            else => |err| return posix.unexpectedErrno(err),
+        }
+    }
+
+    // Connection in progress - use poll() to wait with timeout
+    var fds = [_]posix.pollfd{
+        .{
+            .fd = socket_fd,
+            .events = posix.POLL.OUT, // Wait for socket to become writable
+            .revents = 0,
+        },
+    };
+
+    // Convert nanoseconds to milliseconds for poll()
+    const timeout_ms: i32 = @intCast(@min(timeout_ns / std.time.ns_per_ms, std.math.maxInt(i32)));
+
+    while (true) {
+        try t.checkCancel();
+        const poll_result = posix.poll(&fds, timeout_ms) catch |err| return err;
+
+        if (poll_result == 0) {
+            // Timeout expired
+            return error.Timeout;
+        }
+
+        if (poll_result > 0) {
+            // Socket became writable - check if connection succeeded or failed
+            var socket_err: i32 = 0;
+            var err_len: posix.socklen_t = @sizeOf(i32);
+
+            while (true) {
+                try t.checkCancel();
+                switch (posix.errno(posix.system.getsockopt(
+                    socket_fd,
+                    posix.SOL.SOCKET,
+                    posix.SO.ERROR,
+                    @ptrCast(&socket_err),
+                    &err_len,
+                ))) {
+                    .SUCCESS => break,
+                    .INTR => continue,
+                    .CANCELED => return error.Canceled,
+                    .BADF => |err| return errnoBug(err),
+                    .FAULT => |err| return errnoBug(err),
+                    .INVAL => |err| return errnoBug(err),
+                    .NOPROTOOPT => |err| return errnoBug(err),
+                    .NOTSOCK => |err| return errnoBug(err),
+                    else => |e| return posix.unexpectedErrno(e),
+                }
+            }
+
+            if (socket_err == 0) {
+                // Connection successful
+                return;
+            }
+
+            // Connection failed - translate socket error to Zig error
+            switch (@as(posix.E, @enumFromInt(socket_err))) {
+                .SUCCESS => return,
+                .CONNREFUSED => return error.ConnectionRefused,
+                .CONNRESET => return error.ConnectionResetByPeer,
+                .HOSTUNREACH => return error.HostUnreachable,
+                .NETUNREACH => return error.NetworkUnreachable,
+                .TIMEDOUT => return error.Timeout,
+                .NETDOWN => return error.NetworkDown,
+                .ACCES => return error.AccessDenied,
+                .ADDRNOTAVAIL => return error.AddressUnavailable,
+                else => |e| return posix.unexpectedErrno(e),
+            }
+        }
+
+        // poll_result < 0 would have thrown an error, should not reach here
+        unreachable;
+    }
+}
+
 fn posixConnectUnix(t: *Threaded, fd: posix.socket_t, addr: *const posix.sockaddr, addr_len: posix.socklen_t) !void {
     while (true) {
         try t.checkCancel();
@@ -3449,17 +3562,45 @@ fn netConnectIpPosix(
     options: IpAddress.ConnectOptions,
 ) IpAddress.ConnectError!net.Stream {
     if (!have_networking) return error.NetworkDown;
-    if (options.timeout != .none) @panic("TODO implement netConnectIpPosix with timeout");
     const t: *Threaded = @ptrCast(@alignCast(userdata));
     const family = posixAddressFamily(address);
     const socket_fd = try openSocketPosix(t, family, .{
         .mode = options.mode,
         .protocol = options.protocol,
     });
     errdefer posix.close(socket_fd);
+
+    // Set socket to non-blocking mode if timeout is requested
+    const use_timeout = options.timeout != .none;
+    if (use_timeout) {
+        var fl_flags: usize = while (true) {
+            try t.checkCancel();
+            const flags_rc = posix.system.fcntl(socket_fd, posix.F.GETFL, @as(usize, 0));
+            break switch (posix.errno(flags_rc)) {
+                .SUCCESS => @intCast(flags_rc),
+                .INTR => continue,
+                .CANCELED => return error.Canceled,
+                else => |err| return posix.unexpectedErrno(err),
+            };
+        };
+
+        // Set NONBLOCK bit using bit offset
+        fl_flags |= 1 << @bitOffsetOf(posix.O, "NONBLOCK");
+
+        while (true) {
+            try t.checkCancel();
+            switch (posix.errno(posix.system.fcntl(socket_fd, posix.F.SETFL, fl_flags))) {
+                .SUCCESS => break,
+                .INTR => continue,
+                .CANCELED => return error.Canceled,
+                else => |err| return posix.unexpectedErrno(err),
+            }
+        }
+    }
+
     var storage: PosixAddress = undefined;
     var addr_len = addressToPosix(address, &storage);
-    try posixConnect(t, socket_fd, &storage.any, addr_len);
+
+    // Connect with or without timeout
+    if (use_timeout) {
+        const timeout_ns: u64 = switch (options.timeout) {
+            .none => unreachable, // Already checked above
+            .duration => |dur| @intCast(dur.raw.nanoseconds),
+            .deadline => 3 * std.time.ns_per_s, // TODO: Calculate remaining time from deadline
+        };
+        try posixConnectWithTimeout(t, socket_fd, &storage.any, addr_len, timeout_ns);
+    } else {
+        try posixConnect(t, socket_fd, &storage.any, addr_len);
+    }
+
     try posixGetSockName(t, socket_fd, &storage.any, &addr_len);
     return .{ .socket = .{
         .handle = socket_fd,
--
2.43.0

---
USAGE EXAMPLE:
After applying this patch, timeout support works as follows:

```zig
const std = @import("std");
const Io = std.Io;
const IpAddress = Io.net.IpAddress;

pub fn main() !void {
    var threaded = Io.Threaded.init_single_threaded;
    const io = threaded.io();

    const addr = try IpAddress.parse("1.1.1.1", 80);

    // Connect with 3-second timeout
    const stream = try addr.connect(io, .{
        .mode = .stream,
        .timeout = .{ .duration = .{
            .raw = .{ .nanoseconds = 3 * std.time.ns_per_s },
            .clock = .awake,
        } },
    });
    defer stream.close(io);

    // Connection successful, use stream...
}
```

TESTING:
This implementation has been tested with a production-grade port scanner
that successfully handles:
- Open ports (immediate success)
- Closed ports (connection refused)
- Filtered ports (timeout)
- Unreachable hosts (network/host unreachable)

Test results available at:
https://github.com/zig_forge/zig-port-scanner

---
NOTES FOR REVIEWERS:
1. This follows the existing pattern in posixConnect() for error handling
2. The fcntl approach is used instead of SOCK.NONBLOCK at socket creation
   to maintain compatibility with openSocketPosix()
3. Deadline timeout support needs enhancement (currently uses fixed 3s)
4. Windows equivalent (netConnectIpWindows) needs similar implementation
5. Consider making socket creation accept SOCK.NONBLOCK directly in future
