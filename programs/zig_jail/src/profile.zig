// profile.zig - Security profile parser for zig-jail
// Purpose: Load and parse JSON security profiles from /etc/zig-jail/profiles/

const std = @import("std");

// ============================================================
// Profile Structures (mirrors JSON schema)
// ============================================================

pub const SyscallConfig = struct {
    default_action: []const u8, // "kill", "errno", "allow"
    errno_value: ?u32 = null,
    allowed: [][]const u8,
    blocked: [][]const u8,

    // FEATURE: Conditional Syscall Rules (Planned for V2)
    //
    // The profile JSON schema supports conditional rules (e.g., "allow open() only for
    // read-only access"), but this feature is explicitly deferred to a future release.
    //
    // V1 implements simple allow/block lists. Conditional logic requires:
    // - Syscall argument inspection in seccomp-bpf filters
    // - More complex BPF bytecode generation
    // - Enhanced error reporting for rule violations
    //
    // To implement: See issue #XXX in the project tracker.
    // This comment serves as documentation for why conditional rules in profiles
    // are parsed but not enforced by the V1 seccomp engine.
};

pub const CapabilityConfig = struct {
    drop_all: bool,
    keep: [][]const u8, // Array of capability names like ["CAP_NET_RAW", "CAP_NET_ADMIN"]

    pub fn deinit(self: *CapabilityConfig, allocator: std.mem.Allocator) void {
        for (self.keep) |cap_name| {
            allocator.free(cap_name);
        }
        allocator.free(self.keep);
    }
};

pub const Profile = struct {
    profile_name: []const u8,
    description: []const u8,
    version: []const u8,
    syscalls: SyscallConfig,
    capabilities: ?CapabilityConfig = null, // Optional capability configuration

    allocator: std.mem.Allocator,

    pub fn deinit(self: *Profile) void {
        // Free all allocated memory
        self.allocator.free(self.profile_name);
        self.allocator.free(self.description);
        self.allocator.free(self.version);

        for (self.syscalls.allowed) |syscall| {
            self.allocator.free(syscall);
        }
        self.allocator.free(self.syscalls.allowed);

        for (self.syscalls.blocked) |syscall| {
            self.allocator.free(syscall);
        }
        self.allocator.free(self.syscalls.blocked);

        if (self.capabilities) |*caps| {
            caps.deinit(self.allocator);
        }
    }
};

// ============================================================
// Profile Loading
// ============================================================

const PROFILE_SEARCH_PATHS = [_][]const u8{
    "/etc/zig-jail/profiles",
    "./profiles",
    "/home/founder/zig_forge/profiles",
};

/// Load a profile by name (e.g., "minimal", "python-safe")
pub fn loadProfile(allocator: std.mem.Allocator, profile_name: []const u8) !Profile {
    // Try each search path
    for (PROFILE_SEARCH_PATHS) |base_path| {
        const profile_path = try std.fmt.allocPrint(
            allocator,
            "{s}/{s}.json",
            .{ base_path, profile_name }
        );
        defer allocator.free(profile_path);

        if (loadProfileFromPath(allocator, profile_path)) |profile| {
            std.debug.print("[zig-jail] ✓ Loaded profile: {s}\n", .{profile_path});
            return profile;
        } else |_| {
            continue;
        }
    }

    std.debug.print("[zig-jail] ⚠️  Profile '{s}' not found in search paths\n", .{profile_name});
    return error.ProfileNotFound;
}

fn loadProfileFromPath(allocator: std.mem.Allocator, path: []const u8) !Profile {
    // Open file
    const file = try std.fs.cwd().openFile(path, .{});
    defer file.close();

    // Read content
    const file_size = try file.getEndPos();
    const content = try allocator.alloc(u8, file_size);
    defer allocator.free(content);

    const bytes_read = try file.read(content);
    if (bytes_read != file_size) return error.ReadError;

    // Parse JSON
    return try parseProfile(allocator, content);
}

fn parseProfile(allocator: std.mem.Allocator, json_content: []const u8) !Profile {
    // Parse JSON into std.json.Value
    const parsed = try std.json.parseFromSlice(std.json.Value, allocator, json_content, .{});
    defer parsed.deinit();

    const root = parsed.value.object;

    // Extract top-level fields
    const profile_name = try allocator.dupe(u8, root.get("profile_name").?.string);
    const description = try allocator.dupe(u8, root.get("description").?.string);
    const version = try allocator.dupe(u8, root.get("version").?.string);

    // Parse syscalls section
    const syscalls_obj = root.get("syscalls").?.object;
    const default_action = try allocator.dupe(u8, syscalls_obj.get("default_action").?.string);

    // Parse allowed syscalls
    const allowed_array = syscalls_obj.get("allowed").?.array;
    var allowed = try allocator.alloc([]const u8, allowed_array.items.len);
    for (allowed_array.items, 0..) |item, i| {
        allowed[i] = try allocator.dupe(u8, item.string);
    }

    // Parse blocked syscalls
    const blocked_array = syscalls_obj.get("blocked").?.array;
    var blocked = try allocator.alloc([]const u8, blocked_array.items.len);
    for (blocked_array.items, 0..) |item, i| {
        blocked[i] = try allocator.dupe(u8, item.string);
    }

    // Get optional errno_value
    const errno_value = if (syscalls_obj.get("errno_value")) |val|
        @as(u32, @intCast(val.integer))
    else
        null;

    // Parse optional capabilities section
    var capabilities: ?CapabilityConfig = null;
    if (root.get("capabilities")) |caps_value| {
        const caps_obj = caps_value.object;

        const drop_all = caps_obj.get("drop_all").?.bool;

        // Parse keep array
        const keep_array = caps_obj.get("keep").?.array;
        var keep = try allocator.alloc([]const u8, keep_array.items.len);
        for (keep_array.items, 0..) |item, i| {
            keep[i] = try allocator.dupe(u8, item.string);
        }

        capabilities = CapabilityConfig{
            .drop_all = drop_all,
            .keep = keep,
        };
    }

    return Profile{
        .profile_name = profile_name,
        .description = description,
        .version = version,
        .syscalls = SyscallConfig{
            .default_action = default_action,
            .errno_value = errno_value,
            .allowed = allowed,
            .blocked = blocked,
        },
        .capabilities = capabilities,
        .allocator = allocator,
    };
}

/// Validate that a profile is well-formed
pub fn validateProfile(profile: *const Profile) !void {
    // Check default action is valid
    const valid_actions = [_][]const u8{ "kill", "errno", "allow" };
    var action_valid = false;
    for (valid_actions) |action| {
        if (std.mem.eql(u8, profile.syscalls.default_action, action)) {
            action_valid = true;
            break;
        }
    }
    if (!action_valid) {
        std.debug.print("[zig-jail] ⚠️  Invalid default_action: {s}\n", .{profile.syscalls.default_action});
        return error.InvalidProfile;
    }

    // If default_action is "errno", errno_value must be set
    if (std.mem.eql(u8, profile.syscalls.default_action, "errno")) {
        if (profile.syscalls.errno_value == null) {
            std.debug.print("[zig-jail] ⚠️  default_action is 'errno' but errno_value not set\n", .{});
            return error.InvalidProfile;
        }
    }

    std.debug.print("[zig-jail] ✓ Profile validation passed\n", .{});
}
