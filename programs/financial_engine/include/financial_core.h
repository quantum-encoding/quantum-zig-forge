/**
 * Financial Core - Pure Computational C API
 *
 * This header exposes ONLY the pure, stateless computational logic:
 * - Fixed-point decimal arithmetic (i128, 9 decimal places)
 * - Stateless strategy signal calculation
 * - Zero-copy data access
 *
 * ZERO DEPENDENCIES:
 * - No ZMQ
 * - No networking
 * - No I/O
 * - No global state
 *
 * Thread Safety:
 * - All operations are thread-safe (stateless or handle-based)
 * - Safe to call from multiple threads with different handles
 *
 * Performance:
 * - Sub-microsecond decimal operations
 * - Zero-copy tick processing
 * - No heap allocation in hot path
 *
 * Usage Pattern:
 *   FC_StrategyParams params = { ... };
 *   FC_Strategy* strategy = fc_strategy_create(&params);
 *
 *   FC_MarketTick tick = { ... };
 *   FC_Signal signal;
 *   fc_strategy_on_tick(strategy, &tick, &signal);
 *
 *   fc_strategy_destroy(strategy);
 */

#ifndef FINANCIAL_CORE_H
#define FINANCIAL_CORE_H

#include <stdint.h>
#include <stdbool.h>
#include <stddef.h>

#ifdef __cplusplus
extern "C" {
#endif

/* ============================================================================
 * Core Types
 * ============================================================================ */

/**
 * Fixed-point decimal (i128 with 9 decimal places).
 *
 * Representation: value * 1,000,000,000 = actual_value
 * Example: 1.50 = 1,500,000,000
 */
typedef struct {
    __int128 value;
} FC_Decimal;

/**
 * Market tick (quote update).
 *
 * Borrow semantics:
 * - symbol_ptr must remain valid during fc_strategy_on_tick() call
 * - All price/size values are fixed-point i128 (9 decimals)
 */
typedef struct {
    const uint8_t* symbol_ptr;    /* Symbol string (NOT null-terminated) */
    uint32_t       symbol_len;    /* Symbol length (max 32) */
    __int128       bid_value;     /* Bid price (fixed-point) */
    __int128       ask_value;     /* Ask price (fixed-point) */
    __int128       bid_size_value;/* Bid size (fixed-point) */
    __int128       ask_size_value;/* Ask size (fixed-point) */
    int64_t        timestamp;     /* Unix timestamp (seconds) */
    uint64_t       sequence;      /* Sequence number */
} FC_MarketTick;

/**
 * Trading signal generated by strategy.
 *
 * Action codes:
 * - 0: HOLD (no action)
 * - 1: BUY
 * - 2: SELL
 */
typedef struct {
    uint32_t action;             /* 0=hold, 1=buy, 2=sell */
    float    confidence;         /* Confidence level (0.0 to 1.0) */
    __int128 target_price_value; /* Target price (fixed-point) */
    __int128 quantity_value;     /* Quantity (fixed-point) */
    int64_t  timestamp;          /* Signal timestamp */
} FC_Signal;

/**
 * Strategy parameters.
 *
 * All values are fixed-point i128 (9 decimal places).
 */
typedef struct {
    __int128 max_position_value; /* Max position (fixed-point) */
    __int128 max_spread_value;   /* Max spread (fixed-point) */
    __int128 min_edge_value;     /* Min edge required (fixed-point) */
    uint32_t tick_window;        /* Tick window size */
} FC_StrategyParams;

/**
 * Opaque strategy handle.
 *
 * Lifetime:
 * - Created with fc_strategy_create()
 * - Destroyed with fc_strategy_destroy()
 * - Must not be used after destroy
 */
typedef struct FC_Strategy FC_Strategy;

/**
 * Error codes.
 */
typedef enum {
    FC_SUCCESS = 0,          /* Operation succeeded */
    FC_OUT_OF_MEMORY = -1,   /* Memory allocation failed */
    FC_INVALID_PARAM = -2,   /* Invalid parameter */
    FC_INVALID_HANDLE = -3,  /* Invalid handle (NULL) */
    FC_ARITHMETIC_ERROR = -4,/* Arithmetic error (e.g., division by zero) */
    FC_OVERFLOW = -5,        /* Overflow in arithmetic */
} FC_Error;

/* ============================================================================
 * Decimal Arithmetic (Pure Functions)
 * ============================================================================ */

/**
 * Create decimal from integer.
 *
 * Example: fc_decimal_from_int(100) = 100.000000000 (100 billion internally)
 */
FC_Decimal fc_decimal_from_int(int64_t n);

/**
 * Create decimal from float.
 *
 * WARNING: Precision loss may occur with float representation.
 * Example: fc_decimal_from_float(1.5) = 1.500000000
 */
FC_Decimal fc_decimal_from_float(double f);

/**
 * Convert decimal to float for display.
 *
 * Example: fc_decimal_to_float({ 1500000000 }) = 1.5
 */
double fc_decimal_to_float(FC_Decimal dec);

/**
 * Add two decimals.
 *
 * Returns: FC_SUCCESS or FC_ARITHMETIC_ERROR on overflow
 */
FC_Error fc_decimal_add(FC_Decimal a, FC_Decimal b, FC_Decimal* result);

/**
 * Subtract two decimals.
 *
 * Returns: FC_SUCCESS or FC_ARITHMETIC_ERROR on overflow
 */
FC_Error fc_decimal_sub(FC_Decimal a, FC_Decimal b, FC_Decimal* result);

/**
 * Multiply two decimals.
 *
 * Returns: FC_SUCCESS or FC_OVERFLOW on overflow
 */
FC_Error fc_decimal_mul(FC_Decimal a, FC_Decimal b, FC_Decimal* result);

/**
 * Divide two decimals.
 *
 * Returns: FC_SUCCESS or FC_ARITHMETIC_ERROR on division by zero
 */
FC_Error fc_decimal_div(FC_Decimal a, FC_Decimal b, FC_Decimal* result);

/**
 * Compare two decimals.
 *
 * Returns:
 * - -1 if a < b
 * -  0 if a == b
 * -  1 if a > b
 */
int fc_decimal_compare(FC_Decimal a, FC_Decimal b);

/* ============================================================================
 * Strategy Operations
 * ============================================================================ */

/**
 * Create a new strategy instance.
 *
 * Parameters:
 *   params - Strategy parameters (must not be NULL)
 *
 * Returns:
 *   Strategy handle, or NULL on allocation failure
 *
 * Thread Safety:
 *   Safe to create multiple strategies from different threads
 *
 * Example:
 *   FC_StrategyParams params = {
 *       .max_position_value = fc_decimal_from_float(1000.0).value,
 *       .max_spread_value = fc_decimal_from_float(0.50).value,
 *       .min_edge_value = fc_decimal_from_float(0.05).value,
 *       .tick_window = 100,
 *   };
 *   FC_Strategy* strat = fc_strategy_create(&params);
 */
FC_Strategy* fc_strategy_create(const FC_StrategyParams* params);

/**
 * Destroy strategy and free resources.
 *
 * Parameters:
 *   strategy - Strategy handle (NULL is safe, will be no-op)
 *
 * Thread Safety:
 *   Must be called from the same thread that uses the strategy
 */
void fc_strategy_destroy(FC_Strategy* strategy);

/**
 * Process a market tick and generate trading signal.
 *
 * Parameters:
 *   strategy   - Strategy handle (must not be NULL)
 *   tick       - Market tick data (must not be NULL)
 *   signal_out - Output signal (must not be NULL)
 *
 * Returns:
 *   FC_SUCCESS on success
 *   FC_INVALID_HANDLE if strategy is NULL
 *   FC_INVALID_PARAM if tick is invalid
 *   FC_ARITHMETIC_ERROR on calculation error
 *
 * Performance:
 *   Sub-microsecond processing time
 *   Zero heap allocation (signal uses stack)
 *
 * Signal Output:
 *   If action == 0 (HOLD), no trade should be executed
 *   Otherwise, execute trade with specified price/quantity
 *
 * Example:
 *   FC_MarketTick tick = {
 *       .symbol_ptr = (const uint8_t*)"BTCUSD",
 *       .symbol_len = 6,
 *       .bid_value = fc_decimal_from_float(50000.0).value,
 *       .ask_value = fc_decimal_from_float(50001.0).value,
 *       ...
 *   };
 *   FC_Signal signal;
 *   FC_Error err = fc_strategy_on_tick(strategy, &tick, &signal);
 *   if (err == FC_SUCCESS && signal.action != 0) {
 *       // Execute trade
 *   }
 */
FC_Error fc_strategy_on_tick(
    FC_Strategy* strategy,
    const FC_MarketTick* tick,
    FC_Signal* signal_out
);

/**
 * Update strategy position after trade execution.
 *
 * Parameters:
 *   strategy       - Strategy handle (must not be NULL)
 *   quantity_value - Quantity traded (fixed-point i128)
 *   is_buy         - true if buy, false if sell
 *
 * Returns:
 *   FC_SUCCESS on success
 *   FC_INVALID_HANDLE if strategy is NULL
 *   FC_ARITHMETIC_ERROR on overflow
 *
 * Note:
 *   Call this after successfully executing a trade to keep strategy state updated
 */
FC_Error fc_strategy_update_position(
    FC_Strategy* strategy,
    __int128 quantity_value,
    bool is_buy
);

/**
 * Get current strategy position.
 *
 * Parameters:
 *   strategy - Strategy handle (must not be NULL)
 *
 * Returns:
 *   Current position (fixed-point i128)
 *   Positive = long, Negative = short, Zero = flat
 */
__int128 fc_strategy_get_position(const FC_Strategy* strategy);

/**
 * Get strategy profit & loss.
 *
 * Parameters:
 *   strategy - Strategy handle (must not be NULL)
 *
 * Returns:
 *   Current PnL (fixed-point i128)
 */
__int128 fc_strategy_get_pnl(const FC_Strategy* strategy);

/**
 * Get number of ticks processed.
 *
 * Parameters:
 *   strategy - Strategy handle (must not be NULL)
 *
 * Returns:
 *   Tick count
 */
uint32_t fc_strategy_get_tick_count(const FC_Strategy* strategy);

/* ============================================================================
 * Utility Functions
 * ============================================================================ */

/**
 * Get human-readable error string.
 *
 * Parameters:
 *   error_code - Error code from any function
 *
 * Returns:
 *   Null-terminated error string (always valid, never NULL)
 *
 * Note:
 *   Returned string is static and must not be freed
 */
const char* fc_error_string(FC_Error error_code);

/**
 * Get library version string.
 *
 * Returns:
 *   Null-terminated version string (e.g., "1.0.0-core")
 */
const char* fc_version(void);

#ifdef __cplusplus
}
#endif

#endif /* FINANCIAL_CORE_H */
