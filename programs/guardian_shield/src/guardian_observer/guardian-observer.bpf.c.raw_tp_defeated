// SPDX-License-Identifier: GPL-2.0
/*
 * Guardian Observer - eBPF Syscall Monitor for AI Agents
 *
 * Intercepts critical syscalls from AI agent processes to detect:
 * - Destructive commands
 * - Hallucinated library calls
 * - Pathological patterns
 * - Unauthorized file access
 *
 * Part of The Guardian Protocol
 * Copyright (c) 2025 Richard Tune / Quantum Encoding Ltd
 */

#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

#define TASK_COMM_LEN 16
#define MAX_FILENAME_LEN 256
#define MAX_ARGS_LEN 512

/* Event types */
enum event_type {
    EVENT_EXEC = 1,
    EVENT_OPEN = 2,
    EVENT_UNLINK = 3,
    EVENT_RENAME = 4,
    EVENT_WRITE = 5,
};

/* Syscall numbers (x86_64) */
#define SYS_EXECVE 59
#define SYS_OPENAT 257
#define SYS_UNLINK 87
#define SYS_RENAME 82

/* Syscall event structure */
struct syscall_event {
    __u32 pid;
    __u32 ppid;
    __u32 uid;
    __u32 event_type;
    __u64 timestamp_ns;
    char comm[TASK_COMM_LEN];
    char filename[MAX_FILENAME_LEN];
    char args[MAX_ARGS_LEN];
    __u32 flags;
    __u32 mode;
} __attribute__((packed));

/* Ring buffer for streaming events to userspace */
struct {
    __uint(type, BPF_MAP_TYPE_RINGBUF);
    __uint(max_entries, 256 * 1024); // 256KB ring buffer
} events SEC(".maps");

/* Map to track AI agent processes (PID -> 1 if agent) */
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1024);
    __type(key, __u32);    // PID
    __type(value, __u32);  // 1 if this is an agent process
} agent_processes SEC(".maps");

/* Helper to check if process is an AI agent */
static __always_inline int is_agent_process(__u32 pid)
{
    __u32 *is_agent = bpf_map_lookup_elem(&agent_processes, &pid);
    if (is_agent && *is_agent == 1) {
        return 1;
    }
    return 0;
}

/* Helper to get parent PID - hard-coded offsets for verifier safety */
static __always_inline __u32 get_ppid(void)
{
    struct task_struct *task = (struct task_struct *)bpf_get_current_task();
    if (!task) return 0;

    struct task_struct *parent;
    // Hard-coded offset for task->real_parent (2720 from your kernel layout)
    if (bpf_probe_read_kernel(&parent, sizeof(struct task_struct*), (void *)task + 2720) != 0) return 0;

    __u32 ppid;
    // Hard-coded offset for task->tgid (2708 from your kernel layout)
    if (bpf_probe_read_kernel(&ppid, sizeof(__u32), (void *)parent + 2708) != 0) return 0;

    return ppid;
}

/* Raw tracepoint handler for syscall entry (handles all syscalls) */
SEC("raw_tp/sys_enter")
int trace_sys_enter(struct pt_regs *ctx)
{
    __u64 id = bpf_get_current_pid_tgid();
    __u32 pid = id >> 32;

    // Only monitor agent processes
    if (!is_agent_process(pid)) {
        return 0;
    }

    // Get syscall number from orig_ax (x86_64 pt_regs)
    // Use BPF_CORE_READ to force verifier-friendly code generation
    long syscall_nr = BPF_CORE_READ(ctx, orig_ax);

    struct syscall_event *event;
    event = bpf_ringbuf_reserve(&events, sizeof(*event), 0);
    if (!event) {
        return 0;
    }

    event->pid = pid;
    event->ppid = get_ppid();
    event->uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;
    event->timestamp_ns = bpf_ktime_get_ns();
    bpf_get_current_comm(&event->comm, sizeof(event->comm));

    // Handle based on syscall number
    switch (syscall_nr) {
        case SYS_EXECVE: {
            event->event_type = EVENT_EXEC;
            // Filename in rdi (arg1) - use BPF_CORE_READ
            unsigned long filename_ptr = BPF_CORE_READ(ctx, di);
            bpf_probe_read_user_str(&event->filename, sizeof(event->filename), (const char *)filename_ptr);
            // argv in rsi (arg2) - read first arg for simplicity
            unsigned long argv_ptr = BPF_CORE_READ(ctx, si);
            const char *arg0 = NULL;
            bpf_probe_read_user(&arg0, sizeof(arg0), (const char **)argv_ptr);
            if (arg0) {
                bpf_probe_read_user_str(&event->args, sizeof(event->args), arg0);
            }
            break;
        }

        case SYS_OPENAT: {
            event->event_type = EVENT_OPEN;
            // Filename in rsi (arg2) - use BPF_CORE_READ
            unsigned long filename_ptr = BPF_CORE_READ(ctx, si);
            bpf_probe_read_user_str(&event->filename, sizeof(event->filename), (const char *)filename_ptr);
            // Flags in rdx (arg3), mode in r10 (arg4) - use BPF_CORE_READ
            event->flags = (__u32)BPF_CORE_READ(ctx, dx);
            event->mode = (__u32)BPF_CORE_READ(ctx, r10);
            break;
        }

        case SYS_UNLINK: {
            event->event_type = EVENT_UNLINK;
            // Filename in rdi (arg1) - use BPF_CORE_READ
            unsigned long filename_ptr = BPF_CORE_READ(ctx, di);
            bpf_probe_read_user_str(&event->filename, sizeof(event->filename), (const char *)filename_ptr);
            break;
        }

        case SYS_RENAME: {
            event->event_type = EVENT_RENAME;
            // Old name in rdi (arg1) - use BPF_CORE_READ
            unsigned long oldname_ptr = BPF_CORE_READ(ctx, di);
            bpf_probe_read_user_str(&event->filename, sizeof(event->filename), (const char *)oldname_ptr);
            // New name in rsi (arg2) - use BPF_CORE_READ
            unsigned long newname_ptr = BPF_CORE_READ(ctx, si);
            bpf_probe_read_user_str(&event->args, sizeof(event->args), (const char *)newname_ptr);
            break;
        }

        default:
            // Discard if not monitored syscall
            bpf_ringbuf_discard(event, 0);
            return 0;
    }

    bpf_ringbuf_submit(event, 0);
    return 0;
}

char LICENSE[] SEC("license") = "GPL";
