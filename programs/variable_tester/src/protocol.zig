//! Brute-Force Swarm Protocol
//!
//! Binary protocol for Queen-Worker communication
//! Designed for minimal overhead and zero-copy where possible
//!
//! Message Format:
//! ┌────────┬────────┬────────────────┬─────────────┐
//! │ Magic  │ Type   │ Payload Length │ Payload     │
//! │ 4 bytes│ 1 byte │ 4 bytes        │ N bytes     │
//! └────────┴────────┴────────────────┴─────────────┘

const std = @import("std");
const posix = std.posix;

/// Protocol magic number: "SWRM" (Swarm)
pub const MAGIC: u32 = 0x4D525753; // "SWRM" in little-endian

/// Protocol version
pub const VERSION: u8 = 1;

/// Message types
pub const MessageType = enum(u8) {
    // Worker -> Queen
    worker_hello = 0x01, // Worker announces itself
    request_work = 0x02, // Worker requests a chunk of tasks
    submit_result = 0x03, // Worker submits a successful result
    heartbeat = 0x04, // Worker keepalive

    // Queen -> Worker
    queen_welcome = 0x10, // Queen accepts worker
    dispatch_work = 0x11, // Queen sends task chunk
    no_work = 0x12, // Queen has no work available
    shutdown = 0x13, // Queen tells worker to shut down
    ack_result = 0x14, // Queen acknowledges result

    // Errors
    error_invalid = 0xFE,
    error_protocol = 0xFF,
};

/// Message header (9 bytes)
pub const Header = extern struct {
    magic: u32 align(1),
    msg_type: MessageType align(1),
    payload_len: u32 align(1),

    pub fn init(msg_type: MessageType, payload_len: u32) Header {
        return Header{
            .magic = MAGIC,
            .msg_type = msg_type,
            .payload_len = payload_len,
        };
    }

    pub fn toBytes(self: *const Header) []const u8 {
        return std.mem.asBytes(self);
    }

    pub fn fromBytes(bytes: []const u8) !Header {
        if (bytes.len < @sizeOf(Header)) return error.InsufficientData;
        const header: *const Header = @ptrCast(@alignCast(bytes.ptr));
        if (header.magic != MAGIC) return error.InvalidMagic;
        return header.*;
    }
};

/// Worker hello payload
pub const WorkerHello = extern struct {
    version: u8 align(1),
    cpu_cores: u16 align(1),
    worker_id: u64 align(1), // Random ID generated by worker
    _reserved: [5]u8 align(1) = .{ 0, 0, 0, 0, 0 },

    pub fn init(cpu_cores: u16, worker_id: u64) WorkerHello {
        return WorkerHello{
            .version = VERSION,
            .cpu_cores = cpu_cores,
            .worker_id = worker_id,
        };
    }
};

/// Queen welcome payload
pub const QueenWelcome = extern struct {
    version: u8 align(1),
    assigned_id: u64 align(1), // Queen-assigned worker ID
    chunk_size: u32 align(1), // Preferred chunk size for this worker
    _reserved: [3]u8 align(1) = .{ 0, 0, 0 },

    pub fn init(assigned_id: u64, chunk_size: u32) QueenWelcome {
        return QueenWelcome{
            .version = VERSION,
            .assigned_id = assigned_id,
            .chunk_size = chunk_size,
        };
    }
};

/// Work request payload
pub const WorkRequest = extern struct {
    worker_id: u64 align(1),
    last_task_id: u64 align(1), // Last task ID processed (for resumption)
    requested_count: u32 align(1), // How many tasks worker wants
    _reserved: [4]u8 align(1) = .{ 0, 0, 0, 0 },

    pub fn init(worker_id: u64, last_task_id: u64, requested_count: u32) WorkRequest {
        return WorkRequest{
            .worker_id = worker_id,
            .last_task_id = last_task_id,
            .requested_count = requested_count,
        };
    }
};

/// Work dispatch header (followed by task data)
pub const WorkDispatch = extern struct {
    start_task_id: u64 align(1),
    task_count: u32 align(1),
    test_fn_id: u32 align(1), // Which test function to use
    // Followed by: task_count * TaskEntry

    pub fn init(start_task_id: u64, task_count: u32, test_fn_id: u32) WorkDispatch {
        return WorkDispatch{
            .start_task_id = start_task_id,
            .task_count = task_count,
            .test_fn_id = test_fn_id,
        };
    }
};

/// Task entry in dispatch payload
pub const TaskEntry = extern struct {
    task_id: u64 align(1),
    data_len: u32 align(1),
    // Followed by: data_len bytes of task data

    pub fn init(task_id: u64, data_len: u32) TaskEntry {
        return TaskEntry{
            .task_id = task_id,
            .data_len = data_len,
        };
    }
};

/// Result submission payload
pub const ResultSubmit = extern struct {
    worker_id: u64 align(1),
    task_id: u64 align(1),
    success: u8 align(1),
    score: f64 align(1),
    data_len: u32 align(1),
    // Followed by: data_len bytes of result data

    pub fn init(worker_id: u64, task_id: u64, success: bool, score: f64, data_len: u32) ResultSubmit {
        return ResultSubmit{
            .worker_id = worker_id,
            .task_id = task_id,
            .success = if (success) 1 else 0,
            .score = score,
            .data_len = data_len,
        };
    }
};

/// Heartbeat payload
pub const Heartbeat = extern struct {
    worker_id: u64 align(1),
    tasks_processed: u64 align(1),
    tasks_succeeded: u64 align(1),
    uptime_secs: u32 align(1),
    _reserved: [4]u8 align(1) = .{ 0, 0, 0, 0 },

    pub fn init(worker_id: u64, tasks_processed: u64, tasks_succeeded: u64, uptime_secs: u32) Heartbeat {
        return Heartbeat{
            .worker_id = worker_id,
            .tasks_processed = tasks_processed,
            .tasks_succeeded = tasks_succeeded,
            .uptime_secs = uptime_secs,
        };
    }
};

/// Test function registry (known test functions)
pub const TestFnId = enum(u32) {
    lossless_compression = 0,
    prime_number = 1,
    hash_collision = 2,
    math_formula = 3,
    numeric_match = 4,
    custom = 0xFFFFFFFF,
};

/// Network utilities
pub const Net = struct {
    /// Send a complete message
    pub fn sendMessage(sockfd: posix.socket_t, msg_type: MessageType, payload: []const u8) !void {
        const header = Header.init(msg_type, @intCast(payload.len));

        // Send header
        _ = try posix.send(sockfd, header.toBytes(), 0);

        // Send payload if present
        if (payload.len > 0) {
            _ = try posix.send(sockfd, payload, 0);
        }
    }

    /// Send a message with struct payload
    pub fn sendStruct(sockfd: posix.socket_t, msg_type: MessageType, data: anytype) !void {
        const bytes = std.mem.asBytes(&data);
        try sendMessage(sockfd, msg_type, bytes);
    }

    /// Receive message header (blocking)
    pub fn recvHeader(sockfd: posix.socket_t, buffer: []u8) !Header {
        const header_size = @sizeOf(Header);
        if (buffer.len < header_size) return error.BufferTooSmall;

        var received: usize = 0;
        while (received < header_size) {
            const n = try posix.recv(sockfd, buffer[received..header_size], 0);
            if (n == 0) return error.ConnectionClosed;
            received += n;
        }

        return Header.fromBytes(buffer[0..header_size]);
    }

    /// Receive payload after header
    pub fn recvPayload(sockfd: posix.socket_t, buffer: []u8, len: usize) ![]u8 {
        if (buffer.len < len) return error.BufferTooSmall;
        if (len == 0) return buffer[0..0];

        var received: usize = 0;
        while (received < len) {
            const n = try posix.recv(sockfd, buffer[received..len], 0);
            if (n == 0) return error.ConnectionClosed;
            received += n;
        }

        return buffer[0..len];
    }
};

/// Protocol constants
pub const DEFAULT_PORT: u16 = 7777;
pub const MAX_PAYLOAD_SIZE: u32 = 16 * 1024 * 1024; // 16 MB max payload
pub const DEFAULT_CHUNK_SIZE: u32 = 1000; // Tasks per chunk
pub const HEARTBEAT_INTERVAL_SEC: u32 = 30;
