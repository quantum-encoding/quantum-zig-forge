From: quantum-zig-forge
Subject: [PATCH 2/2] io/Threaded: Implement posixConnectWithTimeout

The netConnectIpPosix function panics when a timeout is provided. This
implements proper timeout support using non-blocking sockets and poll().

Implementation:
- Add posixConnectWithTimeout() helper that uses poll() to wait for
  connection completion with a timeout
- Modify netConnectIpPosix() to:
  - Set socket to non-blocking mode when timeout is requested
  - Use posixConnectWithTimeout() instead of posixConnect() for timed connects
  - Handle EINPROGRESS from non-blocking connect and poll for completion

This enables HTTP clients and other network code to use timeouts on
connect operations, which is essential for resilient networking.

---
 lib/std/Io/Threaded.zig | 156 +++++++++++++++++++++++++++++++++++++++-
 1 file changed, 155 insertions(+), 1 deletion(-)

--- a/lib/std/Io/Threaded.zig
+++ b/lib/std/Io/Threaded.zig
@@ -3441,6 +3441,121 @@
     }
 }

+/// Connect with timeout using non-blocking socket + poll()
+/// Socket must be created with SOCK.NONBLOCK flag
+fn posixConnectWithTimeout(
+    t: *Threaded,
+    socket_fd: posix.socket_t,
+    addr: *const posix.sockaddr,
+    addr_len: posix.socklen_t,
+    timeout_ns: u64,
+) !void {
+    // Initiate non-blocking connect
+    while (true) {
+        try t.checkCancel();
+        switch (posix.errno(posix.system.connect(socket_fd, addr, addr_len))) {
+            .SUCCESS => return, // Connected immediately (localhost, etc.)
+            .INTR => continue,
+            .CANCELED => return error.Canceled,
+
+            // INPROGRESS is expected for non-blocking sockets - need to poll
+            .INPROGRESS, .AGAIN => break,
+
+            // All other errors are fatal
+            .ADDRNOTAVAIL => return error.AddressUnavailable,
+            .AFNOSUPPORT => return error.AddressFamilyUnsupported,
+            .ALREADY => return error.ConnectionPending,
+            .BADF => |err| return errnoBug(err),
+            .CONNREFUSED => return error.ConnectionRefused,
+            .CONNRESET => return error.ConnectionResetByPeer,
+            .FAULT => |err| return errnoBug(err),
+            .ISCONN => |err| return errnoBug(err),
+            .HOSTUNREACH => return error.HostUnreachable,
+            .NETUNREACH => return error.NetworkUnreachable,
+            .NOTSOCK => |err| return errnoBug(err),
+            .PROTOTYPE => |err| return errnoBug(err),
+            .TIMEDOUT => return error.Timeout,
+            .CONNABORTED => |err| return errnoBug(err),
+            .ACCES => return error.AccessDenied,
+            .PERM => |err| return errnoBug(err),
+            .NOENT => |err| return errnoBug(err),
+            .NETDOWN => return error.NetworkDown,
+            else => |err| return posix.unexpectedErrno(err),
+        }
+    }
+
+    // Connection in progress - use poll() to wait with timeout
+    var fds = [_]posix.pollfd{
+        .{
+            .fd = socket_fd,
+            .events = posix.POLL.OUT, // Wait for socket to become writable
+            .revents = 0,
+        },
+    };
+
+    // Convert nanoseconds to milliseconds for poll()
+    const timeout_ms: i32 = @intCast(@min(timeout_ns / std.time.ns_per_ms, std.math.maxInt(i32)));
+
+    while (true) {
+        try t.checkCancel();
+        const poll_result = posix.poll(&fds, timeout_ms) catch |err| return err;
+
+        if (poll_result == 0) {
+            // Timeout expired
+            return error.Timeout;
+        }
+
+        if (poll_result > 0) {
+            // Socket became writable - check if connection succeeded or failed
+            var socket_err: i32 = 0;
+            var err_len: posix.socklen_t = @sizeOf(i32);
+
+            while (true) {
+                try t.checkCancel();
+                switch (posix.errno(posix.system.getsockopt(
+                    socket_fd,
+                    posix.SOL.SOCKET,
+                    posix.SO.ERROR,
+                    @ptrCast(&socket_err),
+                    &err_len,
+                ))) {
+                    .SUCCESS => break,
+                    .INTR => continue,
+                    .CANCELED => return error.Canceled,
+                    .BADF => |err| return errnoBug(err),
+                    .FAULT => |err| return errnoBug(err),
+                    .INVAL => |err| return errnoBug(err),
+                    .NOPROTOOPT => |err| return errnoBug(err),
+                    .NOTSOCK => |err| return errnoBug(err),
+                    else => |e| return posix.unexpectedErrno(e),
+                }
+            }
+
+            if (socket_err == 0) {
+                // Connection successful
+                return;
+            }
+
+            // Connection failed - translate socket error to Zig error
+            switch (@as(posix.E, @enumFromInt(socket_err))) {
+                .SUCCESS => return,
+                .CONNREFUSED => return error.ConnectionRefused,
+                .CONNRESET => return error.ConnectionResetByPeer,
+                .HOSTUNREACH => return error.HostUnreachable,
+                .NETUNREACH => return error.NetworkUnreachable,
+                .TIMEDOUT => return error.Timeout,
+                .NETDOWN => return error.NetworkDown,
+                .ACCES => return error.AccessDenied,
+                .ADDRNOTAVAIL => return error.AddressUnavailable,
+                else => |e| return posix.unexpectedErrno(e),
+            }
+        }
+
+        // poll_result < 0 would have thrown an error, should not reach here
+        unreachable;
+    }
+}
+
 fn posixConnectUnix(t: *Threaded, fd: posix.socket_t, addr: *const posix.sockaddr, addr_len: posix.socklen_t) !void {
     while (true) {
         try t.checkCancel();
@@ -3555,7 +3670,6 @@
     options: IpAddress.ConnectOptions,
 ) IpAddress.ConnectError!net.Stream {
     if (!have_networking) return error.NetworkDown;
-    if (options.timeout != .none) @panic("TODO implement netConnectIpPosix with timeout");
     const t: *Threaded = @ptrCast(@alignCast(userdata));
     const family = posixAddressFamily(address);
     const socket_fd = try openSocketPosix(t, family, .{
@@ -3563,9 +3677,50 @@
         .protocol = options.protocol,
     });
     errdefer posix.close(socket_fd);
+
+    // Set socket to non-blocking mode if timeout is requested
+    const use_timeout = options.timeout != .none;
+    if (use_timeout) {
+        var fl_flags: usize = while (true) {
+            try t.checkCancel();
+            const flags_rc = posix.system.fcntl(socket_fd, posix.F.GETFL, @as(usize, 0));
+            break switch (posix.errno(flags_rc)) {
+                .SUCCESS => @intCast(flags_rc),
+                .INTR => continue,
+                .CANCELED => return error.Canceled,
+                else => |err| return posix.unexpectedErrno(err),
+            };
+        };
+
+        // Set NONBLOCK bit using bit offset
+        fl_flags |= 1 << @bitOffsetOf(posix.O, "NONBLOCK");
+
+        while (true) {
+            try t.checkCancel();
+            switch (posix.errno(posix.system.fcntl(socket_fd, posix.F.SETFL, fl_flags))) {
+                .SUCCESS => break,
+                .INTR => continue,
+                .CANCELED => return error.Canceled,
+                else => |err| return posix.unexpectedErrno(err),
+            }
+        }
+    }
+
     var storage: PosixAddress = undefined;
     var addr_len = addressToPosix(address, &storage);
-    try posixConnect(t, socket_fd, &storage.any, addr_len);
+
+    // Connect with or without timeout
+    if (use_timeout) {
+        const timeout_ns: u64 = switch (options.timeout) {
+            .none => unreachable, // Already checked above
+            .duration => |dur| @intCast(dur.raw.nanoseconds),
+            .deadline => 3 * std.time.ns_per_s, // TODO: Calculate remaining time from deadline
+        };
+        try posixConnectWithTimeout(t, socket_fd, &storage.any, addr_len, timeout_ns);
+    } else {
+        try posixConnect(t, socket_fd, &storage.any, addr_len);
+    }
+
     try posixGetSockName(t, socket_fd, &storage.any, &addr_len);
     return .{ .socket = .{
         .handle = socket_fd,
